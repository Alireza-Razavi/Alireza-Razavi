# Report

Audit report for **2024-01-curves** generated by *ubl4nk_bot*.

## Medium Issues


*Total <b>2</b> instances over <b>1</b> issue:*

|ID|Issue|Instances|
|-|:-|:-:|
| [M-1](#M-1) | `call()` should be used instead of `transfer()`/`send()` on an address payable | 2 |

## Low Issues


*Total <b>99</b> instances over <b>18</b> issues:*

|ID|Issue|Instances|
|-|:-|:-:|
| [L-1](#L-1) | Missing zero address check in functions with address parameters | 31 |
| [L-2](#L-2) | Array is `push()`ed but not `pop()`ed | 2 |
| [L-3](#L-3) | Division by zero not prevented | 2 |
| [L-4](#L-4) | Consider implementing two-step procedure for updating protocol addresses | 5 |
| [L-5](#L-5) | Constructor / initialization function lacks parameter validation | 2 |
| [L-6](#L-6) | Empty `receive()`/`fallback()` function | 1 |
| [L-7](#L-7) | Governance functions should be controlled by time locks | 3 |
| [L-8](#L-8) | Loss of precision in divisions | 5 |
| [L-9](#L-9) | Missing checks for state variable assignments | 8 |
| [L-10](#L-10) | Missing zero address check in constructor | 1 |
| [L-11](#L-11) | Consider some checks for `address(0)` when setting address state variables | 4 |
| [L-12](#L-12) | Owner can renounce Ownership | 1 |
| [L-13](#L-13) | `receive()`/`fallback()` function does not authorize requests | 1 |
| [L-14](#L-14) | Solidity version 0.8.20 or above may not work on other chains due to PUSH0 | 5 |
| [L-15](#L-15) | Tokens may be minted to `address(0)` | 2 |
| [L-16](#L-16) | Use Ownable2Step instead of Ownable | 1 |
| [L-17](#L-17) |  `abi.encodePacked()` should not be used with dynamic types when passing the result to a hash function such as `keccak256()` | 9 |
| [L-18](#L-18) | Centralization Risk for trusted owners | 16 |

## Non Critical Issues


*Total <b>605</b> instances over <b>75</b> issues:*

|ID|Issue|Instances|
|-|:-|:-:|
| [NC-1](#NC-1) | `abi.encodePacked()` should be replaced with `bytes.concat()` | 11 |
| [NC-2](#NC-2) | Avoid the use of sensitive terms | 4 |
| [NC-3](#NC-3) | Multiple `address`/ID mappings can be combined into a single `mapping` of an `address`/ID to a `struct`, for readability | 2 |
| [NC-4](#NC-4) | Consider adding a block/deny-list | 5 |
| [NC-5](#NC-5) | Consider adding emergency-stop functionality | 5 |
| [NC-6](#NC-6) | Consider adding formal verification proofs | 1 |
| [NC-7](#NC-7) | Consider bounding input array length | 1 |
| [NC-8](#NC-8) | Constants should be put on the left side of comparisons | 17 |
| [NC-9](#NC-9) | `Constructor` should emit an event | 4 |
| [NC-10](#NC-10) | Contract does not follow the Solidity Style Guide's suggested layout ordering | 22 |
| [NC-11](#NC-11) | Contract should expose an `interface` | 41 |
| [NC-12](#NC-12) | Contracts should each be defined in separate files | 2 |
| [NC-13](#NC-13) | Contracts should have full test coverage | 1 |
| [NC-14](#NC-14) | Events that mark critical parameter changes should contain both the old and the new value | 5 |
| [NC-15](#NC-15) | Custom errors has no error details | 19 |
| [NC-16](#NC-16) | Enable IR-based code generation | 1 |
| [NC-17](#NC-17) | Events are emitted without the sender information | 2 |
| [NC-18](#NC-18) | Events may be emitted out of order due to reentrancy | 1 |
| [NC-19](#NC-19) | External call recipient can consume all remaining gas | 1 |
| [NC-20](#NC-20) |  Function ordering does not follow the Solidity Style Guide | 20 |
| [NC-21](#NC-21) | Functions with array parameters should have length checks in place | 3 |
| [NC-22](#NC-22) | High cyclomatic complexity | 1 |
| [NC-23](#NC-23) | Import declarations should import specific identifiers, rather than the whole file | 12 |
| [NC-24](#NC-24) | Imports could be organized more systematically | 1 |
| [NC-25](#NC-25) | Inconsistent spacing in comments | 2 |
| [NC-26](#NC-26) | Interfaces should have an `I` prefix in the contract name | 1 |
| [NC-27](#NC-27) | Invalid NatSpec comment style | 2 |
| [NC-28](#NC-28) | Large or complicated code bases should implement invariant tests | 1 |
| [NC-29](#NC-29) | Large numeric literals should use underscores for readability | 1 |
| [NC-30](#NC-30) | Magic numbers should be replaced with constants | 5 |
| [NC-31](#NC-31) | Missing contract existence checks before low-level calls | 1 |
| [NC-32](#NC-32) | Named mappings are recommended | 14 |
| [NC-33](#NC-33) | Named imports of parent contracts are missing | 3 |
| [NC-34](#NC-34) | Missing NatSpec from contract declarations | 6 |
| [NC-35](#NC-35) | Missing NatSpec `@author` from contract declaration | 6 |
| [NC-36](#NC-36) | Missing NatSpec `@dev` from contract declaration | 6 |
| [NC-37](#NC-37) | Missing NatSpec `@dev` from event declaration | 5 |
| [NC-38](#NC-38) | Missing NatSpec `@dev` from function declaration | 53 |
| [NC-39](#NC-39) | Missing NatSpec `@dev` from modifier declaration | 3 |
| [NC-40](#NC-40) | Error declarations should have NatSpec descriptions | 19 |
| [NC-41](#NC-41) | Event declarations should have NatSpec descriptions | 5 |
| [NC-42](#NC-42) | NatSpec documentation for function is missing | 53 |
| [NC-43](#NC-43) | Modifier declarations should have NatSpec descriptions | 3 |
| [NC-44](#NC-44) | Public variable declarations should have NatSpec descriptions | 16 |
| [NC-45](#NC-45) | Missing NatSpec `@notice` from contract declaration | 6 |
| [NC-46](#NC-46) | Missing NatSpec `@notice` from event declaration | 5 |
| [NC-47](#NC-47) | Missing NatSpec `@notice` from function declaration | 53 |
| [NC-48](#NC-48) | Missing NatSpec `@notice` from modifier declaration | 3 |
| [NC-49](#NC-49) | Missing NatSpec `@param` from event declaration | 5 |
| [NC-50](#NC-50) | Missing NatSpec `@param` from function declaration | 50 |
| [NC-51](#NC-51) | Missing NatSpec `@param` from modifier declaration | 1 |
| [NC-52](#NC-52) | Missing NatSpec `@return` from function declaration | 13 |
| [NC-53](#NC-53) | Missing NatSpec `@title` from contract declaration | 6 |
| [NC-54](#NC-54) | There is no need to initialize variables with 0 | 6 |
| [NC-55](#NC-55) | Potential Re-org Attack Vector | 1 |
| [NC-56](#NC-56) | Put all system-wide constants in one file | 3 |
| [NC-57](#NC-57) | The remaining ETH may be locked in the contract after call | 1 |
| [NC-58](#NC-58) | Setters should prevent re-setting the same value | 4 |
| [NC-59](#NC-59) | State variables should include comments | 6 |
| [NC-60](#NC-60) | Unnecessary cast | 1 |
| [NC-61](#NC-61) | Unsafe solidity low-level call can cause gas grief attack | 1 |
| [NC-62](#NC-62) | Consider using `delete` rather than assigning zero/false to clear values | 2 |
| [NC-63](#NC-63) | Solidity compiler version is not fixed | 5 |
| [NC-64](#NC-64) | Expressions for constant values should use `immutable` rather than `constant` | 3 |
| [NC-65](#NC-65) | Use the latest solidity version for deployment (`0.8.23`) | 5 |
| [NC-66](#NC-66) | Consider using modifiers for address control | 2 |
| [NC-67](#NC-67) | Returning a struct instead of a bunch of variables is better | 1 |
| [NC-68](#NC-68) | Visibility of state variables is not explicitly defined | 1 |
| [NC-69](#NC-69) | Whitespace in Expressions | 4 |
| [NC-70](#NC-70) | Empty body - Consider commenting why | 2 |
| [NC-71](#NC-71) | Names of `private`/`internal` functions should be prefixed with an underscore | 1 |
| [NC-72](#NC-72) | Names of `private`/`internal` state variables should be prefixed with an underscore | 4 |
| [NC-73](#NC-73) | Internal function calls within for loops | 2 |
| [NC-74](#NC-74) | Event is missing `indexed` fields | 3 |
| [NC-75](#NC-75) | Functions not used internally could be marked `external` | 18 |

## Gas Optimizations


*Total <b>205</b> instances over <b>38</b> issues:*

|ID|Issue|Instances|Gas|
|-|:-|:-:|:-:|
| [GAS-1](#GAS-1) | Assigning to structs can be more efficient | 1 | 6 |
| [GAS-2](#GAS-2) | Optimize gas by using do-while loops | 4 | 1020 |
| [GAS-3](#GAS-3) | Multiple `address`/ID mappings can be combined into a single `mapping` of an `address`/ID to a `struct`, where appropriate | 2 | - |
| [GAS-4](#GAS-4) | Consider activating via-ir for deploying | 1 | - |
| [GAS-5](#GAS-5) | Divisions can be `unchecked` to save gas | 12 | 240 |
| [GAS-6](#GAS-6) | Operator `+=` costs more gas than `<x> = <x> + <y>` for state variables | 1 | 113 |
| [GAS-7](#GAS-7) | Events should be emitted outside of loops | 1 | 375 |
| [GAS-8](#GAS-8) | Increments can be `unchecked` to save gas | 4 | 240 |
| [GAS-9](#GAS-9) | Low level `call` can be optimized with assembly | 3 | 744 |
| [GAS-10](#GAS-10) | Multiple accesses of the same mapping/array key/index should be cached | 30 | 1260 |
| [GAS-11](#GAS-11) | Newer versions of solidity are more gas efficient | 5 | - |
| [GAS-12](#GAS-12) | Operator `>=`/`<=` costs less gas than operator `>`/`<` | 16 | 48 |
| [GAS-13](#GAS-13) | Optimize Gas by splitting `if() revert` statements | 1 | - |
| [GAS-14](#GAS-14) | Optimize names to save gas | 5 | 110 |
| [GAS-15](#GAS-15) | Reduce gas usage by moving to Solidity 0.8.19 or later | 5 | 5000 |
| [GAS-16](#GAS-16) | Unlimited gas consumption risk due to external call recipients | 1 | - |
| [GAS-17](#GAS-17) | Optimize external calls with assembly for memory efficiency | 1 | 220 |
| [GAS-18](#GAS-18) | Use assembly to compute hashes to save gas | 11 | 880 |
| [GAS-19](#GAS-19) | Use assembly to emit events | 6 | 228 |
| [GAS-20](#GAS-20) | Use assembly to validate `msg.sender` | 2 | - |
| [GAS-21](#GAS-21) | Use assembly to write address/contract type storage values | 7 | 350 |
| [GAS-22](#GAS-22) | Using a double `if` statement instead of a logical AND (`&&`) | 3 | 90 |
| [GAS-23](#GAS-23) | Use a more recent version of solidity | 5 | - |
| [GAS-24](#GAS-24) | Use `uint256(1)`/`uint256(2)` instead of `true`/`false` to save gas for changes | 1 | 8550 |
| [GAS-25](#GAS-25) | Use `unchecked` block for safe subtractions | 4 | 340 |
| [GAS-26](#GAS-26) | Using bitmap to store bool states can save gas | 1 | - |
| [GAS-27](#GAS-27) | Using `constant`s directly, rather than caching the value, saves gas | 4 | - |
| [GAS-28](#GAS-28) | `array[index] += amount` is cheaper than `array[index] = array[index] + amount` (or related variants) | 2 | - |
| [GAS-29](#GAS-29) | Using bools for storage incurs overhead | 1 | 100 |
| [GAS-30](#GAS-30) | Cache array length outside of loop | 4 | - |
| [GAS-31](#GAS-31) | State variables should be cached in stack variables rather than re-reading them from storage | 2 | 194 |
| [GAS-32](#GAS-32) | Use `calldata` instead of `memory` for function arguments that do not get mutated | 10 | - |
| [GAS-33](#GAS-33) | Don't initialize variables with default value | 6 | - |
| [GAS-34](#GAS-34) | Constructors can be marked as `payable` to save deployment gas | 4 | 84 |
| [GAS-35](#GAS-35) | Functions guaranteed to revert when called by normal users can be marked `payable` | 11 | 231 |
| [GAS-36](#GAS-36) | `++i` costs less gas than `i++`, especially when it's used in `for`-loops (`--i`/`i--` too) | 4 | 20 |
| [GAS-37](#GAS-37) | Using `private` rather than `public` for constants, saves gas | 2 | - |
| [GAS-38](#GAS-38) | Using assembly to check for zero can save gas | 22 | 132 |

## Medium Issues

<a name="M-1"></a> 
### [M-1] `call()` should be used instead of `transfer()`/`send()` on an address payable
The `transfer()` and `send()` functions forward a fixed amount of 2300 gas. Historically, it has often been recommended to use these functions for value transfers to guard against reentrancy attacks. However, the gas cost of EVM instructions may change significantly during hard forks which may break already deployed contract systems that make fixed assumptions about gas costs. For example. EIP 1884 broke several existing smart contracts due to a cost increase of the `SLOAD` instruction.

*There are <b>2</b> instances of this issue:*
```solidity
File: contracts/FeeSplitter.sol

85:         payable(msg.sender).transfer(claimable);

116:         payable(msg.sender).transfer(totalClaimable);

```



## Low Issues

<a name="L-1"></a> 
### [L-1] Missing zero address check in functions with address parameters
Adding a zero address check for each address type parameter can prevent errors.

<details>
<summary>
There are <b>31</b> instances (click to show):
</summary>

```solidity
File: contracts/Curves.sol

/// @audit missing zero check for `referralFeeDestination_`
155:     function setReferralFeeDestination(
             address curvesTokenSubject,
             address referralFeeDestination_
         ) public onlyTokenSubject(curvesTokenSubject) {

/// @audit missing zero check for `factory_`
162:     function setERC20Factory(address factory_) external onlyOwner {

/// @audit missing zero check for `curvesTokenSubject`
189:     function getBuyPrice(address curvesTokenSubject, uint256 amount) public view returns (uint256) {

/// @audit missing zero check for `curvesTokenSubject`
193:     function getSellPrice(address curvesTokenSubject, uint256 amount) public view returns (uint256) {

/// @audit missing zero check for `curvesTokenSubject`
197:     function getBuyPriceAfterFee(address curvesTokenSubject, uint256 amount) public view returns (uint256) {

/// @audit missing zero check for `curvesTokenSubject`
204:     function getSellPriceAfterFee(address curvesTokenSubject, uint256 amount) public view returns (uint256) {

/// @audit missing zero check for `curvesTokenSubject`
211:     function buyCurvesToken(address curvesTokenSubject, uint256 amount) public payable {

/// @audit missing zero check for `curvesTokenSubject`
263:     function _buyCurvesToken(address curvesTokenSubject, uint256 amount) internal {

/// @audit missing zero check for `curvesTokenSubject`
282:     function sellCurvesToken(address curvesTokenSubject, uint256 amount) public {

/// @audit missing zero check for `curvesTokenSubject`
296:     function transferCurvesToken(address curvesTokenSubject, address to, uint256 amount) external {

/// @audit missing zero check for `curvesTokenSubject`
/// @audit missing zero check for `from`
/// @audit missing zero check for `to`
313:     function _transfer(address curvesTokenSubject, address from, address to, uint256 amount) internal {

/// @audit missing zero check for `owner_`
328:     function _addOwnedCurvesTokenSubject(address owner_, address curvesTokenSubject) internal {

/// @audit missing zero check for `curvesTokenSubject`
338:     function _deployERC20(
             address curvesTokenSubject,
             string memory name,
             string memory symbol
         ) internal returns (address) {

/// @audit missing zero check for `curvesTokenSubject`
364:     function buyCurvesTokenWithName(
             address curvesTokenSubject,
             uint256 amount,
             string memory name,
             string memory symbol
         ) public payable {

/// @audit missing zero check for `curvesTokenSubject`
404:     function buyCurvesTokenWhitelisted(
             address curvesTokenSubject,
             uint256 amount,
             bytes32[] memory proof
         ) public payable {

/// @audit missing zero check for `curvesTokenSubject`
422:     function verifyMerkle(address curvesTokenSubject, address caller, bytes32[] memory proof) public view {

/// @audit missing zero check for `curvesTokenSubject`
465:     function withdraw(address curvesTokenSubject, uint256 amount) public {

/// @audit missing zero check for `curvesTokenSubject`
490:     function deposit(address curvesTokenSubject, uint256 amount) public {

/// @audit missing zero check for `curvesTokenSubject`
504:     function sellExternalCurvesToken(address curvesTokenSubject, uint256 amount) public {

```

```solidity
File: contracts/CurvesERC20.sol

/// @audit missing zero check for `to`
12:     function mint(address to, uint256 amount) public onlyOwner {

/// @audit missing zero check for `from`
16:     function burn(address from, uint256 amount) public onlyOwner {

```

```solidity
File: contracts/CurvesERC20Factory.sol

/// @audit missing zero check for `owner`
7:     function deploy(string memory name, string memory symbol, address owner) public returns (address) {

```

```solidity
File: contracts/FeeSplitter.sol

/// @audit missing zero check for `curves_`
35:     function setCurves(Curves curves_) public {

/// @audit missing zero check for `token`
/// @audit missing zero check for `account`
39:     function balanceOf(address token, address account) public view returns (uint256) {

/// @audit missing zero check for `user`
48:     function getUserTokens(address user) public view returns (address[] memory) {

/// @audit missing zero check for `token`
/// @audit missing zero check for `account`
63:     function updateFeeCredit(address token, address account) internal {

/// @audit missing zero check for `token`
/// @audit missing zero check for `account`
73:     function getClaimableFees(address token, address account) public view returns (uint256) {

/// @audit missing zero check for `token`
80:     function claimFees(address token) external {

/// @audit missing zero check for `account`
96:     function onBalanceChange(address token, address account) public onlyManager {

```

```solidity
File: contracts/Security.sol

/// @audit missing zero check for `manager_`
23:     function setManager(address manager_, bool value) public onlyOwner {

/// @audit missing zero check for `owner_`
27:     function transferOwnership(address owner_) public onlyOwner {

```

</details>


<a name="L-2"></a> 
### [L-2] Array is `push()`ed but not `pop()`ed
There is no limit specified on the amount of gas used, so the recipient can use up all of the remaining gas (`gasleft()`), causing it to revert. Therefore, when calling an external contract, it is necessary to specify a limited amount of gas to forward.

*There are <b>2</b> instances of this issue:*
```solidity
File: contracts/Curves.sol

335:         subjects.push(curvesTokenSubject);

```

```solidity
File: contracts/FeeSplitter.sol

99:         if (balanceOf(token, account) > 0) userTokens[account].push(token);

```


<a name="L-3"></a> 
### [L-3] Division by zero not prevented
The divisions below take an input parameter that has no zero-value checks, which can cause the functions reverting if zero is passed.

*There are <b>2</b> instances of this issue:*
```solidity
File: contracts/FeeSplitter.sol

/// @audit `PRECISION`
68:             data.unclaimedFees[account] += owed / PRECISION;

/// @audit `PRECISION`
77:         return (owed / PRECISION) + data.unclaimedFees[account];

```


<a name="L-4"></a> 
### [L-4] Consider implementing two-step procedure for updating protocol addresses
A copy-paste error or a typo may end up bricking protocol functionality, or sending tokens to an address with no known private key. Consider implementing a two-step procedure for updating protocol addresses, where the recipient is set as pending, and must "accept" the assignment by making an affirmative call. A straight forward way of doing this would be to have the target contracts implement [EIP-165](https://eips.ethereum.org/EIPS/eip-165), and to have the "set" functions ensure that the recipient is of the right interface type.

*There are <b>5</b> instances of this issue:*
```solidity
File: contracts/Curves.sol

/// @audit `feeRedistributor`
113:     function setFeeRedistributor(address feeRedistributor_) external onlyOwner {

/// @audit `referralFeeDestination`
155:     function setReferralFeeDestination(
             address curvesTokenSubject,
             address referralFeeDestination_
         ) public onlyTokenSubject(curvesTokenSubject) {

/// @audit `curvesERC20Factory`
162:     function setERC20Factory(address factory_) external onlyOwner {

```

```solidity
File: contracts/FeeSplitter.sol

/// @audit `curves`
35:     function setCurves(Curves curves_) public {

```

```solidity
File: contracts/Security.sol

/// @audit `owner`
27:     function transferOwnership(address owner_) public onlyOwner {

```


<a name="L-5"></a> 
### [L-5] Constructor / initialization function lacks parameter validation
Constructors and initialization functions play a critical role in contracts by setting important initial states when the contract is first deployed before the system starts. The parameters passed to the constructor and initialization functions directly affect the behavior of the contract / protocol. If incorrect parameters are provided, the system may fail to run, behave abnormally, be unstable, or lack security. Therefore, it's crucial to carefully check each parameter in the constructor and initialization functions. If an exception is found, the transaction should be rolled back.

*There are <b>2</b> instances of this issue:*
```solidity
File: contracts/Curves.sol

/// @audit `curvesERC20Factory_` not validated
108:     constructor(address curvesERC20Factory_, address feeRedistributor_) Security() {

```

```solidity
File: contracts/CurvesERC20.sol

/// @audit `name_` not validated
/// @audit `symbol_` not validated
8:     constructor(string memory name_, string memory symbol_, address owner) ERC20(name_, symbol_) {

```


<a name="L-6"></a> 
### [L-6] Empty `receive()`/`fallback()` function
If the intention is for Ether sent by a caller to be used for an actual purpose (i.e. the function is not just a WETH `withdraw()` handler), the function should call another function (e.g. call `weth.deposit()` and use the token on the caller's behalf) or at least emit an event to track that funds were sent directly to it.

*There is one instance of this issue:*
```solidity
File: contracts/FeeSplitter.sol

119:     receive() external payable {}

```


<a name="L-7"></a> 
### [L-7] Governance functions should be controlled by time locks
Governance functions (such as upgrading contracts, setting critical parameters) should be controlled using time locks to introduce a delay between a proposal and its execution. This gives users time to exit before a potentially dangerous or malicious operation is applied.

*There are <b>3</b> instances of this issue:*
```solidity
File: contracts/Curves.sol

113:     function setFeeRedistributor(address feeRedistributor_) external onlyOwner {

117:     function setMaxFeePercent(uint256 maxFeePercent_) external onlyManager {

162:     function setERC20Factory(address factory_) external onlyOwner {

```


<a name="L-8"></a> 
### [L-8] Loss of precision in divisions
Division by large numbers may result in the result being zero, due to solidity not supporting fractions. Consider requiring a minimum amount for the numerator to ensure that it is always larger than the denominator.

*There are <b>5</b> instances of this issue:*
```solidity
File: contracts/FeeSplitter.sol

45:         return (curves.curvesTokenSupply(token) - curves.curvesTokenBalance(token, address(curves))) * PRECISION;

67:             uint256 owed = (data.cumulativeFeePerToken - data.userFeeOffset[account]) * balance;

76:         uint256 owed = (data.cumulativeFeePerToken - data.userFeeOffset[account]) * balance;

77:         return (owed / PRECISION) + data.unclaimedFees[account];

93:         data.cumulativeFeePerToken += (msg.value * PRECISION) / totalSupply_;

```


<a name="L-9"></a> 
### [L-9] Missing checks for state variable assignments
There are some missing checks in these functions, and this could lead to unexpected scenarios. Consider always adding a sanity check for state variables.

*There are <b>8</b> instances of this issue:*
```solidity
File: contracts/Curves.sol

/// @audit `curvesERC20Factory_`
109:         curvesERC20Factory = curvesERC20Factory_;

/// @audit `referralFeeDestination_`
159:         referralFeeDestination[curvesTokenSubject] = referralFeeDestination_;

/// @audit `factory_`
163:         curvesERC20Factory = factory_;

/// @audit `curvesTokenSubject`
357:         externalCurvesToSubject[tokenContract] = curvesTokenSubject;

/// @audit `curvesTokenSubject`
358:         symbolToSubject[symbol] = curvesTokenSubject;

```

```solidity
File: contracts/FeeSplitter.sol

/// @audit `curves_`
36:         curves = curves_;

```

```solidity
File: contracts/Security.sol

/// @audit `value`
24:         managers[manager_] = value;

/// @audit `owner_`
28:         owner = owner_;

```


<a name="L-10"></a> 
### [L-10] Missing zero address check in constructor
Constructors often take address parameters to initialize important components of a contract, such as owner or linked contracts. However, without a checking, there's a risk that an address parameter could be mistakenly set to the zero address (0x0). This could be due to an error or oversight during contract deployment. A zero address in a crucial role can cause serious issues, as it cannot perform actions like a normal address, and any funds sent to it will be irretrievable. It's therefore crucial to include a zero address check in constructors to prevent such potential problems. If a zero address is detected, the constructor should revert the transaction.

*There is one instance of this issue:*
```solidity
File: contracts/Curves.sol

/// @audit missing zero check for `curvesERC20Factory_`
108:     constructor(address curvesERC20Factory_, address feeRedistributor_) Security() {

```


<a name="L-11"></a> 
### [L-11] Consider some checks for `address(0)` when setting address state variables
Check for zero-address to avoid the risk of setting `address(0)` for state variables after an update.

*There are <b>4</b> instances of this issue:*
```solidity
File: contracts/Curves.sol

/// @audit `curvesERC20Factory_`
109:         curvesERC20Factory = curvesERC20Factory_;

/// @audit `factory_`
163:         curvesERC20Factory = factory_;

```

```solidity
File: contracts/FeeSplitter.sol

/// @audit `curves_`
36:         curves = curves_;

```

```solidity
File: contracts/Security.sol

/// @audit `owner_`
28:         owner = owner_;

```


<a name="L-12"></a> 
### [L-12] Owner can renounce Ownership
Each of the following contracts implements or inherits the `renounceOwnership()` function. This can represent a certain risk if the ownership is renounced for any other reason than by design. Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner.

*There is one instance of this issue:*
```solidity
File: contracts/CurvesERC20.sol

7: contract CurvesERC20 is ERC20, Ownable {

```


<a name="L-13"></a> 
### [L-13] `receive()`/`fallback()` function does not authorize requests
Having no access control on the function (e.g. `require(msg.sender == address(weth))`) means that someone may send Ether to the contract, and have no way to get anything back out, which is a loss of funds. If the concern is having to spend a small amount of gas to check the sender against an immutable address, the code should at least have a function to rescue mistakenly-sent Ether.

*There is one instance of this issue:*
```solidity
File: contracts/FeeSplitter.sol

119:     receive() external payable {}

```


<a name="L-14"></a> 
### [L-14] Solidity version 0.8.20 or above may not work on other chains due to PUSH0
Solidity version 0.8.20 or above uses the new [Shanghai EVM](https://blog.soliditylang.org/2023/05/10/solidity-0.8.20-release-announcement/#important-note) which introduces the PUSH0 opcode. This op code may not yet be implemented on all evm-chains or Layer2s, so deployment on these chains will fail. Consider using an earlier solidity version.

*There are <b>5</b> instances of this issue:*
```solidity
File: contracts/Curves.sol

2: pragma solidity ^0.8.7;

```

```solidity
File: contracts/CurvesERC20.sol

2: pragma solidity ^0.8.7;

```

```solidity
File: contracts/CurvesERC20Factory.sol

2: pragma solidity ^0.8.7;

```

```solidity
File: contracts/FeeSplitter.sol

2: pragma solidity ^0.8.7;

```

```solidity
File: contracts/Security.sol

2: pragma solidity ^0.8.7;

```


<a name="L-15"></a> 
### [L-15] Tokens may be minted to `address(0)`

*There are <b>2</b> instances of this issue:*
```solidity
File: contracts/Curves.sol

439:     function mint(address curvesTokenSubject) external onlyTokenSubject(curvesTokenSubject) {
             if (
                 keccak256(abi.encodePacked(externalCurvesTokens[curvesTokenSubject].name)) ==
                 keccak256(abi.encodePacked("")) ||
                 keccak256(abi.encodePacked(externalCurvesTokens[curvesTokenSubject].symbol)) ==
                 keccak256(abi.encodePacked(""))
             ) {
                 externalCurvesTokens[curvesTokenSubject].name = DEFAULT_NAME;
                 externalCurvesTokens[curvesTokenSubject].symbol = DEFAULT_SYMBOL;
             }
             _mint(
                 curvesTokenSubject,
                 externalCurvesTokens[curvesTokenSubject].name,
                 externalCurvesTokens[curvesTokenSubject].symbol
             );
         }

```

```solidity
File: contracts/CurvesERC20.sol

12:     function mint(address to, uint256 amount) public onlyOwner {
            _mint(to, amount);
        }

```


<a name="L-16"></a> 
### [L-16] Use Ownable2Step instead of Ownable
`Ownable2Step` and `Ownable2StepUpgradeable` prevent the contract ownership from mistakenly being transferred to an address that cannot handle it (e.g. due to a typo in the address), by requiring that the recipient of the owner permissions actively accept via a contract call of its own.

*There is one instance of this issue:*
```solidity
File: contracts/CurvesERC20.sol

7: contract CurvesERC20 is ERC20, Ownable {

```


<a name="L-17"></a> 
### [L-17]  `abi.encodePacked()` should not be used with dynamic types when passing the result to a hash function such as `keccak256()`
Use `abi.encode()` instead which will pad items to 32 bytes, which will [prevent hash collisions](https://docs.soliditylang.org/en/v0.8.13/abi-spec.html#non-standard-packed-mode) (e.g. `abi.encodePacked(0x123,0x456)` => `0x123456` => `abi.encodePacked(0x1,0x23456)`, but `abi.encode(0x123,0x456)` => `0x0...1230...456`). "Unless there is a compelling reason, `abi.encode` should be preferred". If there is only one argument to `abi.encodePacked()` it can often be cast to `bytes()` or `bytes32()` [instead](https://ethereum.stackexchange.com/questions/30912/how-to-compare-strings-in-solidity#answer-82739).
If all arguments are strings and or bytes, `bytes.concat()` should be used instead

*There are <b>9</b> instances of this issue:*
```solidity
File: contracts/Curves.sol

424:         bytes32 leaf = keccak256(abi.encodePacked(caller));

441:             keccak256(abi.encodePacked(externalCurvesTokens[curvesTokenSubject].name)) ==

442:             keccak256(abi.encodePacked("")) ||

443:             keccak256(abi.encodePacked(externalCurvesTokens[curvesTokenSubject].symbol)) ==

444:             keccak256(abi.encodePacked(""))

471:                 keccak256(abi.encodePacked(externalCurvesTokens[curvesTokenSubject].name)) ==

472:                 keccak256(abi.encodePacked("")) ||

473:                 keccak256(abi.encodePacked(externalCurvesTokens[curvesTokenSubject].symbol)) ==

474:                 keccak256(abi.encodePacked(""))

```


<a name="L-18"></a> 
### [L-18] Centralization Risk for trusted owners
Contracts have owners with privileged rights to perform admin tasks and need to be trusted to not perform malicious updates or drain funds.

<details>
<summary>
There are <b>16</b> instances (click to show):
</summary>

```solidity
File: contracts/Curves.sol

113:     function setFeeRedistributor(address feeRedistributor_) external onlyOwner {

117:     function setMaxFeePercent(uint256 maxFeePercent_) external onlyManager {

128:     function setProtocolFeePercent(uint256 protocolFeePercent_, address protocolFeeDestination_) external onlyOwner {

141:     function setExternalFeePercent(
             uint256 subjectFeePercent_,
             uint256 referralFeePercent_,
             uint256 holdersFeePercent_
         ) external onlyManager {

155:     function setReferralFeeDestination(
             address curvesTokenSubject,
             address referralFeeDestination_
         ) public onlyTokenSubject(curvesTokenSubject) {

162:     function setERC20Factory(address factory_) external onlyOwner {

377:     function buyCurvesTokenForPresale(
             address curvesTokenSubject,
             uint256 amount,
             uint256 startTime,
             bytes32 merkleRoot,
             uint256 maxBuy
         ) public payable onlyTokenSubject(curvesTokenSubject) {

428:     function setNameAndSymbol(
             address curvesTokenSubject,
             string memory name,
             string memory symbol
         ) external onlyTokenSubject(curvesTokenSubject) {

439:     function mint(address curvesTokenSubject) external onlyTokenSubject(curvesTokenSubject) {

456:     function _mint(
             address curvesTokenSubject,
             string memory name,
             string memory symbol
         ) internal onlyTokenSubject(curvesTokenSubject) {

```

```solidity
File: contracts/CurvesERC20.sol

12:     function mint(address to, uint256 amount) public onlyOwner {

16:     function burn(address from, uint256 amount) public onlyOwner {

```

```solidity
File: contracts/FeeSplitter.sol

89:     function addFees(address token) public payable onlyManager {

96:     function onBalanceChange(address token, address account) public onlyManager {

```

```solidity
File: contracts/Security.sol

23:     function setManager(address manager_, bool value) public onlyOwner {

27:     function transferOwnership(address owner_) public onlyOwner {

```

</details>



## Non Critical Issues

<a name="NC-1"></a> 
### [NC-1] `abi.encodePacked()` should be replaced with `bytes.concat()`
Solidity version 0.8.4 introduces `bytes.concat()`, which can be used to replace `abi.encodePacked()` on bytes/strings. It can make the intended operation clearer, leading to less reviewer confusion.

<details>
<summary>
There are <b>11</b> instances (click to show):
</summary>

```solidity
File: contracts/Curves.sol

346:             name = string(abi.encodePacked(name, " ", Strings.toString(_curvesTokenCounter)));

347:             symbol = string(abi.encodePacked(symbol, Strings.toString(_curvesTokenCounter)));

424:         bytes32 leaf = keccak256(abi.encodePacked(caller));

441:             keccak256(abi.encodePacked(externalCurvesTokens[curvesTokenSubject].name)) ==

442:             keccak256(abi.encodePacked("")) ||

443:             keccak256(abi.encodePacked(externalCurvesTokens[curvesTokenSubject].symbol)) ==

444:             keccak256(abi.encodePacked(""))

471:                 keccak256(abi.encodePacked(externalCurvesTokens[curvesTokenSubject].name)) ==

472:                 keccak256(abi.encodePacked("")) ||

473:                 keccak256(abi.encodePacked(externalCurvesTokens[curvesTokenSubject].symbol)) ==

474:                 keccak256(abi.encodePacked(""))

```

</details>


<a name="NC-2"></a> 
### [NC-2] Avoid the use of sensitive terms
Use [alternative variants](https://www.zdnet.com/article/mysql-drops-master-slave-and-blacklist-whitelist-terminology/), e.g. allowlist/denylist instead of whitelist/blacklist

*There are <b>4</b> instances of this issue:*
```solidity
File: contracts/Curves.sol

92:     event WhitelistUpdated(address indexed presale, bytes32 indexed root);

394:     function setWhitelist(bytes32 merkleRoot) external {

400:             emit WhitelistUpdated(msg.sender, merkleRoot);

404:     function buyCurvesTokenWhitelisted(

```


<a name="NC-3"></a> 
### [NC-3] Multiple `address`/ID mappings can be combined into a single `mapping` of an `address`/ID to a `struct`, for readability
Well-organized data structures make code reviews easier, which may lead to fewer bugs. Consider combining related mappings into mappings to structs, so it's clear what data is related

*There are <b>2</b> instances of this issue:*
```solidity
File: contracts/Curves.sol

66:     mapping(address => mapping(address => uint256)) public presalesBuys;

96:     mapping(address => mapping(address => uint256)) public curvesTokenBalance;

```


<a name="NC-4"></a> 
### [NC-4] Consider adding a block/deny-list
Doing so will significantly increase centralization, but will help to prevent hackers from using stolen tokens.

*There are <b>5</b> instances of this issue:*
```solidity
File: contracts/Curves.sol

41: contract Curves is CurvesErrors, Security {

```

```solidity
File: contracts/CurvesERC20.sol

7: contract CurvesERC20 is ERC20, Ownable {

```

```solidity
File: contracts/CurvesERC20Factory.sol

6: contract CurvesERC20Factory {

```

```solidity
File: contracts/FeeSplitter.sol

9: contract FeeSplitter is Security {

```

```solidity
File: contracts/Security.sol

4: contract Security {

```


<a name="NC-5"></a> 
### [NC-5] Consider adding emergency-stop functionality
Consider adding `Pausable` to the following contracts so it's possible to stop them in case of an emergency.

*There are <b>5</b> instances of this issue:*
```solidity
File: contracts/Curves.sol

41: contract Curves is CurvesErrors, Security {

```

```solidity
File: contracts/CurvesERC20.sol

7: contract CurvesERC20 is ERC20, Ownable {

```

```solidity
File: contracts/CurvesERC20Factory.sol

6: contract CurvesERC20Factory {

```

```solidity
File: contracts/FeeSplitter.sol

9: contract FeeSplitter is Security {

```

```solidity
File: contracts/Security.sol

4: contract Security {

```


<a name="NC-6"></a> 
### [NC-6] Consider adding formal verification proofs
Formal verification is the act of proving or disproving the correctness of intended algorithms underlying a system with respect to a certain formal specification/property/invariant, using formal methods of mathematics.

Some tools that are currently available to perform these tests on smart contracts are [SMTChecker](https://docs.soliditylang.org/en/latest/smtchecker.html) and [Certora Prover](https://www.certora.com/).

*There is one instance of this issue:*
```solidity

Global finding

```


<a name="NC-7"></a> 
### [NC-7] Consider bounding input array length
The functions below take in an unbounded array, and make function calls for entries in the array. While the function will revert if it eventually runs out of gas, it may be a nicer user experience to require() that the length of the array is below some reasonable maximum, so that the user doesn't have to use up a full transaction's gas only to see that the transaction reverts.

*There is one instance of this issue:*
```solidity
File: contracts/FeeSplitter.sol

/// @audit consider length check for `tokenList`
105:         for (uint256 i = 0; i < tokenList.length; i++) {

```


<a name="NC-8"></a> 
### [NC-8] Constants should be put on the left side of comparisons
Putting constants on the left side of comparison statements is a best practice known as [Yoda conditions](https://en.wikipedia.org/wiki/Yoda_conditions). Although solidity's static typing system prevents accidental assignments within conditionals, adopting this practice can improve code readability and consistency, especially when working across multiple languages.

<details>
<summary>
There are <b>17</b> instances (click to show):
</summary>

```solidity
File: contracts/Curves.sol

213:         if (startTime != 0 && startTime >= block.timestamp) revert SaleNotOpen();

246:             if (feesEconomics.holdersFeePercent > 0 && address(feeRedistributor) != address(0)) {

277:         if (curvesTokenBalance[curvesTokenSubject][msg.sender] - amount == 0) {

350:         if (symbolToSubject[symbol] != address(0)) revert InvalidERC20Metadata();

371:         if (supply != 0) revert CurveAlreadyExists();

386:         if (supply != 0) revert CurveAlreadyExists();

389:         presalesMeta[curvesTokenSubject].maxBuy = (maxBuy == 0 ? type(uint256).max : maxBuy);

433:         if (externalCurvesTokens[curvesTokenSubject].token != address(0)) revert ERC20TokenAlreadyMinted();

434:         if (symbolToSubject[symbol] != address(0)) revert InvalidERC20Metadata();

461:         if (externalCurvesTokens[curvesTokenSubject].token != address(0)) revert ERC20TokenAlreadyMinted();

469:         if (externalToken == address(0)) {

491:         if (amount % 1 ether != 0) revert NonIntegerDepositAmount();

496:         if (externalToken == address(0)) revert TokenAbsentForCurvesTokenSubject();

505:         if (externalCurvesTokens[curvesTokenSubject].token == address(0)) revert TokenAbsentForCurvesTokenSubject();

```

```solidity
File: contracts/FeeSplitter.sol

83:         if (claimable == 0) revert NoFeesToClaim();

91:         if (totalSupply_ == 0) revert NoTokenHolders();

115:         if (totalClaimable == 0) revert NoFeesToClaim();

```

</details>


<a name="NC-9"></a> 
### [NC-9] `Constructor` should emit an event
Use events to signal significant changes to off-chain monitoring tools.

*There are <b>4</b> instances of this issue:*
```solidity
File: contracts/Curves.sol

108:     constructor(address curvesERC20Factory_, address feeRedistributor_) Security() {

```

```solidity
File: contracts/CurvesERC20.sol

8:     constructor(string memory name_, string memory symbol_, address owner) ERC20(name_, symbol_) {

```

```solidity
File: contracts/FeeSplitter.sol

33:     constructor() Security() {}

```

```solidity
File: contracts/Security.sol

18:     constructor() {

```


<a name="NC-10"></a> 
### [NC-10] Contract does not follow the Solidity Style Guide's suggested layout ordering
The [style guide](https://docs.soliditylang.org/en/v0.8.16/style-guide.html#order-of-layout) says that, within a contract, the ordering should be `1) Type declarations`, `2) State variables`, `3) Events`, `4) Modifiers`, and `5) Functions`, but the contract(s) below do not follow this ordering

<details>
<summary>
There are <b>22</b> instances (click to show):
</summary>

```solidity
File: contracts/Curves.sol

/// @audit event/error `UnauthorizedCurvesTokenSubject` came earlier
/// @audit event/error `InsufficientPayment` came earlier
/// @audit event/error `CannotSendFunds` came earlier
/// @audit event/error `InsufficientBalance` came earlier
/// @audit event/error `InvalidERC20Metadata` came earlier
/// @audit event/error `ERC20TokenAlreadyMinted` came earlier
/// @audit event/error `TokenAbsentForCurvesTokenSubject` came earlier
/// @audit event/error `CurveAlreadyExists` came earlier
/// @audit event/error `LastTokenCannotBeSold` came earlier
/// @audit event/error `ContractCannotReceiveTransfer` came earlier
/// @audit event/error `ExceededMaxBuyAmount` came earlier
/// @audit event/error `NonIntegerDepositAmount` came earlier
/// @audit event/error `UnverifiedProof` came earlier
/// @audit event/error `PresaleUnavailable` came earlier
/// @audit event/error `InvalidPresaleStartTime` came earlier
/// @audit event/error `SaleNotOpen` came earlier
/// @audit event/error `InvalidFeeDefinition` came earlier
42:     address public curvesERC20Factory;

/// @audit event/error `UnauthorizedCurvesTokenSubject` came earlier
/// @audit event/error `InsufficientPayment` came earlier
/// @audit event/error `CannotSendFunds` came earlier
/// @audit event/error `InsufficientBalance` came earlier
/// @audit event/error `InvalidERC20Metadata` came earlier
/// @audit event/error `ERC20TokenAlreadyMinted` came earlier
/// @audit event/error `TokenAbsentForCurvesTokenSubject` came earlier
/// @audit event/error `CurveAlreadyExists` came earlier
/// @audit event/error `LastTokenCannotBeSold` came earlier
/// @audit event/error `ContractCannotReceiveTransfer` came earlier
/// @audit event/error `ExceededMaxBuyAmount` came earlier
/// @audit event/error `NonIntegerDepositAmount` came earlier
/// @audit event/error `UnverifiedProof` came earlier
/// @audit event/error `PresaleUnavailable` came earlier
/// @audit event/error `InvalidPresaleStartTime` came earlier
/// @audit event/error `SaleNotOpen` came earlier
/// @audit event/error `InvalidFeeDefinition` came earlier
43:     FeeSplitter public feeRedistributor;

/// @audit event/error `UnauthorizedCurvesTokenSubject` came earlier
/// @audit event/error `InsufficientPayment` came earlier
/// @audit event/error `CannotSendFunds` came earlier
/// @audit event/error `InsufficientBalance` came earlier
/// @audit event/error `InvalidERC20Metadata` came earlier
/// @audit event/error `ERC20TokenAlreadyMinted` came earlier
/// @audit event/error `TokenAbsentForCurvesTokenSubject` came earlier
/// @audit event/error `CurveAlreadyExists` came earlier
/// @audit event/error `LastTokenCannotBeSold` came earlier
/// @audit event/error `ContractCannotReceiveTransfer` came earlier
/// @audit event/error `ExceededMaxBuyAmount` came earlier
/// @audit event/error `NonIntegerDepositAmount` came earlier
/// @audit event/error `UnverifiedProof` came earlier
/// @audit event/error `PresaleUnavailable` came earlier
/// @audit event/error `InvalidPresaleStartTime` came earlier
/// @audit event/error `SaleNotOpen` came earlier
/// @audit event/error `InvalidFeeDefinition` came earlier
44:     string public constant DEFAULT_NAME = "Curves";

/// @audit event/error `UnauthorizedCurvesTokenSubject` came earlier
/// @audit event/error `InsufficientPayment` came earlier
/// @audit event/error `CannotSendFunds` came earlier
/// @audit event/error `InsufficientBalance` came earlier
/// @audit event/error `InvalidERC20Metadata` came earlier
/// @audit event/error `ERC20TokenAlreadyMinted` came earlier
/// @audit event/error `TokenAbsentForCurvesTokenSubject` came earlier
/// @audit event/error `CurveAlreadyExists` came earlier
/// @audit event/error `LastTokenCannotBeSold` came earlier
/// @audit event/error `ContractCannotReceiveTransfer` came earlier
/// @audit event/error `ExceededMaxBuyAmount` came earlier
/// @audit event/error `NonIntegerDepositAmount` came earlier
/// @audit event/error `UnverifiedProof` came earlier
/// @audit event/error `PresaleUnavailable` came earlier
/// @audit event/error `InvalidPresaleStartTime` came earlier
/// @audit event/error `SaleNotOpen` came earlier
/// @audit event/error `InvalidFeeDefinition` came earlier
45:     string public constant DEFAULT_SYMBOL = "CURVES";

/// @audit event/error `UnauthorizedCurvesTokenSubject` came earlier
/// @audit event/error `InsufficientPayment` came earlier
/// @audit event/error `CannotSendFunds` came earlier
/// @audit event/error `InsufficientBalance` came earlier
/// @audit event/error `InvalidERC20Metadata` came earlier
/// @audit event/error `ERC20TokenAlreadyMinted` came earlier
/// @audit event/error `TokenAbsentForCurvesTokenSubject` came earlier
/// @audit event/error `CurveAlreadyExists` came earlier
/// @audit event/error `LastTokenCannotBeSold` came earlier
/// @audit event/error `ContractCannotReceiveTransfer` came earlier
/// @audit event/error `ExceededMaxBuyAmount` came earlier
/// @audit event/error `NonIntegerDepositAmount` came earlier
/// @audit event/error `UnverifiedProof` came earlier
/// @audit event/error `PresaleUnavailable` came earlier
/// @audit event/error `InvalidPresaleStartTime` came earlier
/// @audit event/error `SaleNotOpen` came earlier
/// @audit event/error `InvalidFeeDefinition` came earlier
47:     uint256 private _curvesTokenCounter = 0;

/// @audit state variable `curvesERC20Factory` came earlier
/// @audit state variable `feeRedistributor` came earlier
/// @audit state variable `DEFAULT_NAME` came earlier
/// @audit state variable `DEFAULT_SYMBOL` came earlier
/// @audit state variable `_curvesTokenCounter` came earlier
/// @audit event/error `UnauthorizedCurvesTokenSubject` came earlier
/// @audit event/error `InsufficientPayment` came earlier
/// @audit event/error `CannotSendFunds` came earlier
/// @audit event/error `InsufficientBalance` came earlier
/// @audit event/error `InvalidERC20Metadata` came earlier
/// @audit event/error `ERC20TokenAlreadyMinted` came earlier
/// @audit event/error `TokenAbsentForCurvesTokenSubject` came earlier
/// @audit event/error `CurveAlreadyExists` came earlier
/// @audit event/error `LastTokenCannotBeSold` came earlier
/// @audit event/error `ContractCannotReceiveTransfer` came earlier
/// @audit event/error `ExceededMaxBuyAmount` came earlier
/// @audit event/error `NonIntegerDepositAmount` came earlier
/// @audit event/error `UnverifiedProof` came earlier
/// @audit event/error `PresaleUnavailable` came earlier
/// @audit event/error `InvalidPresaleStartTime` came earlier
/// @audit event/error `SaleNotOpen` came earlier
/// @audit event/error `InvalidFeeDefinition` came earlier
49:     struct ExternalTokenMeta {

/// @audit state variable `curvesERC20Factory` came earlier
/// @audit state variable `feeRedistributor` came earlier
/// @audit state variable `DEFAULT_NAME` came earlier
/// @audit state variable `DEFAULT_SYMBOL` came earlier
/// @audit state variable `_curvesTokenCounter` came earlier
/// @audit event/error `UnauthorizedCurvesTokenSubject` came earlier
/// @audit event/error `InsufficientPayment` came earlier
/// @audit event/error `CannotSendFunds` came earlier
/// @audit event/error `InsufficientBalance` came earlier
/// @audit event/error `InvalidERC20Metadata` came earlier
/// @audit event/error `ERC20TokenAlreadyMinted` came earlier
/// @audit event/error `TokenAbsentForCurvesTokenSubject` came earlier
/// @audit event/error `CurveAlreadyExists` came earlier
/// @audit event/error `LastTokenCannotBeSold` came earlier
/// @audit event/error `ContractCannotReceiveTransfer` came earlier
/// @audit event/error `ExceededMaxBuyAmount` came earlier
/// @audit event/error `NonIntegerDepositAmount` came earlier
/// @audit event/error `UnverifiedProof` came earlier
/// @audit event/error `PresaleUnavailable` came earlier
/// @audit event/error `InvalidPresaleStartTime` came earlier
/// @audit event/error `SaleNotOpen` came earlier
/// @audit event/error `InvalidFeeDefinition` came earlier
55:     struct PresaleMeta {

/// @audit event/error `UnauthorizedCurvesTokenSubject` came earlier
/// @audit event/error `InsufficientPayment` came earlier
/// @audit event/error `CannotSendFunds` came earlier
/// @audit event/error `InsufficientBalance` came earlier
/// @audit event/error `InvalidERC20Metadata` came earlier
/// @audit event/error `ERC20TokenAlreadyMinted` came earlier
/// @audit event/error `TokenAbsentForCurvesTokenSubject` came earlier
/// @audit event/error `CurveAlreadyExists` came earlier
/// @audit event/error `LastTokenCannotBeSold` came earlier
/// @audit event/error `ContractCannotReceiveTransfer` came earlier
/// @audit event/error `ExceededMaxBuyAmount` came earlier
/// @audit event/error `NonIntegerDepositAmount` came earlier
/// @audit event/error `UnverifiedProof` came earlier
/// @audit event/error `PresaleUnavailable` came earlier
/// @audit event/error `InvalidPresaleStartTime` came earlier
/// @audit event/error `SaleNotOpen` came earlier
/// @audit event/error `InvalidFeeDefinition` came earlier
61:     mapping(address => ExternalTokenMeta) public externalCurvesTokens;

/// @audit event/error `UnauthorizedCurvesTokenSubject` came earlier
/// @audit event/error `InsufficientPayment` came earlier
/// @audit event/error `CannotSendFunds` came earlier
/// @audit event/error `InsufficientBalance` came earlier
/// @audit event/error `InvalidERC20Metadata` came earlier
/// @audit event/error `ERC20TokenAlreadyMinted` came earlier
/// @audit event/error `TokenAbsentForCurvesTokenSubject` came earlier
/// @audit event/error `CurveAlreadyExists` came earlier
/// @audit event/error `LastTokenCannotBeSold` came earlier
/// @audit event/error `ContractCannotReceiveTransfer` came earlier
/// @audit event/error `ExceededMaxBuyAmount` came earlier
/// @audit event/error `NonIntegerDepositAmount` came earlier
/// @audit event/error `UnverifiedProof` came earlier
/// @audit event/error `PresaleUnavailable` came earlier
/// @audit event/error `InvalidPresaleStartTime` came earlier
/// @audit event/error `SaleNotOpen` came earlier
/// @audit event/error `InvalidFeeDefinition` came earlier
62:     mapping(address => address) public externalCurvesToSubject;

/// @audit event/error `UnauthorizedCurvesTokenSubject` came earlier
/// @audit event/error `InsufficientPayment` came earlier
/// @audit event/error `CannotSendFunds` came earlier
/// @audit event/error `InsufficientBalance` came earlier
/// @audit event/error `InvalidERC20Metadata` came earlier
/// @audit event/error `ERC20TokenAlreadyMinted` came earlier
/// @audit event/error `TokenAbsentForCurvesTokenSubject` came earlier
/// @audit event/error `CurveAlreadyExists` came earlier
/// @audit event/error `LastTokenCannotBeSold` came earlier
/// @audit event/error `ContractCannotReceiveTransfer` came earlier
/// @audit event/error `ExceededMaxBuyAmount` came earlier
/// @audit event/error `NonIntegerDepositAmount` came earlier
/// @audit event/error `UnverifiedProof` came earlier
/// @audit event/error `PresaleUnavailable` came earlier
/// @audit event/error `InvalidPresaleStartTime` came earlier
/// @audit event/error `SaleNotOpen` came earlier
/// @audit event/error `InvalidFeeDefinition` came earlier
63:     mapping(string => address) public symbolToSubject;

/// @audit event/error `UnauthorizedCurvesTokenSubject` came earlier
/// @audit event/error `InsufficientPayment` came earlier
/// @audit event/error `CannotSendFunds` came earlier
/// @audit event/error `InsufficientBalance` came earlier
/// @audit event/error `InvalidERC20Metadata` came earlier
/// @audit event/error `ERC20TokenAlreadyMinted` came earlier
/// @audit event/error `TokenAbsentForCurvesTokenSubject` came earlier
/// @audit event/error `CurveAlreadyExists` came earlier
/// @audit event/error `LastTokenCannotBeSold` came earlier
/// @audit event/error `ContractCannotReceiveTransfer` came earlier
/// @audit event/error `ExceededMaxBuyAmount` came earlier
/// @audit event/error `NonIntegerDepositAmount` came earlier
/// @audit event/error `UnverifiedProof` came earlier
/// @audit event/error `PresaleUnavailable` came earlier
/// @audit event/error `InvalidPresaleStartTime` came earlier
/// @audit event/error `SaleNotOpen` came earlier
/// @audit event/error `InvalidFeeDefinition` came earlier
65:     mapping(address => PresaleMeta) public presalesMeta;

/// @audit event/error `UnauthorizedCurvesTokenSubject` came earlier
/// @audit event/error `InsufficientPayment` came earlier
/// @audit event/error `CannotSendFunds` came earlier
/// @audit event/error `InsufficientBalance` came earlier
/// @audit event/error `InvalidERC20Metadata` came earlier
/// @audit event/error `ERC20TokenAlreadyMinted` came earlier
/// @audit event/error `TokenAbsentForCurvesTokenSubject` came earlier
/// @audit event/error `CurveAlreadyExists` came earlier
/// @audit event/error `LastTokenCannotBeSold` came earlier
/// @audit event/error `ContractCannotReceiveTransfer` came earlier
/// @audit event/error `ExceededMaxBuyAmount` came earlier
/// @audit event/error `NonIntegerDepositAmount` came earlier
/// @audit event/error `UnverifiedProof` came earlier
/// @audit event/error `PresaleUnavailable` came earlier
/// @audit event/error `InvalidPresaleStartTime` came earlier
/// @audit event/error `SaleNotOpen` came earlier
/// @audit event/error `InvalidFeeDefinition` came earlier
66:     mapping(address => mapping(address => uint256)) public presalesBuys;

/// @audit state variable `curvesERC20Factory` came earlier
/// @audit state variable `feeRedistributor` came earlier
/// @audit state variable `DEFAULT_NAME` came earlier
/// @audit state variable `DEFAULT_SYMBOL` came earlier
/// @audit state variable `_curvesTokenCounter` came earlier
/// @audit state variable `externalCurvesTokens` came earlier
/// @audit state variable `externalCurvesToSubject` came earlier
/// @audit state variable `symbolToSubject` came earlier
/// @audit state variable `presalesMeta` came earlier
/// @audit state variable `presalesBuys` came earlier
/// @audit event/error `UnauthorizedCurvesTokenSubject` came earlier
/// @audit event/error `InsufficientPayment` came earlier
/// @audit event/error `CannotSendFunds` came earlier
/// @audit event/error `InsufficientBalance` came earlier
/// @audit event/error `InvalidERC20Metadata` came earlier
/// @audit event/error `ERC20TokenAlreadyMinted` came earlier
/// @audit event/error `TokenAbsentForCurvesTokenSubject` came earlier
/// @audit event/error `CurveAlreadyExists` came earlier
/// @audit event/error `LastTokenCannotBeSold` came earlier
/// @audit event/error `ContractCannotReceiveTransfer` came earlier
/// @audit event/error `ExceededMaxBuyAmount` came earlier
/// @audit event/error `NonIntegerDepositAmount` came earlier
/// @audit event/error `UnverifiedProof` came earlier
/// @audit event/error `PresaleUnavailable` came earlier
/// @audit event/error `InvalidPresaleStartTime` came earlier
/// @audit event/error `SaleNotOpen` came earlier
/// @audit event/error `InvalidFeeDefinition` came earlier
68:     struct FeesEconomics {

/// @audit event/error `UnauthorizedCurvesTokenSubject` came earlier
/// @audit event/error `InsufficientPayment` came earlier
/// @audit event/error `CannotSendFunds` came earlier
/// @audit event/error `InsufficientBalance` came earlier
/// @audit event/error `InvalidERC20Metadata` came earlier
/// @audit event/error `ERC20TokenAlreadyMinted` came earlier
/// @audit event/error `TokenAbsentForCurvesTokenSubject` came earlier
/// @audit event/error `CurveAlreadyExists` came earlier
/// @audit event/error `LastTokenCannotBeSold` came earlier
/// @audit event/error `ContractCannotReceiveTransfer` came earlier
/// @audit event/error `ExceededMaxBuyAmount` came earlier
/// @audit event/error `NonIntegerDepositAmount` came earlier
/// @audit event/error `UnverifiedProof` came earlier
/// @audit event/error `PresaleUnavailable` came earlier
/// @audit event/error `InvalidPresaleStartTime` came earlier
/// @audit event/error `SaleNotOpen` came earlier
/// @audit event/error `InvalidFeeDefinition` came earlier
77:     FeesEconomics public feesEconomics;

/// @audit event/error `UnauthorizedCurvesTokenSubject` came earlier
/// @audit event/error `InsufficientPayment` came earlier
/// @audit event/error `CannotSendFunds` came earlier
/// @audit event/error `InsufficientBalance` came earlier
/// @audit event/error `InvalidERC20Metadata` came earlier
/// @audit event/error `ERC20TokenAlreadyMinted` came earlier
/// @audit event/error `TokenAbsentForCurvesTokenSubject` came earlier
/// @audit event/error `CurveAlreadyExists` came earlier
/// @audit event/error `LastTokenCannotBeSold` came earlier
/// @audit event/error `ContractCannotReceiveTransfer` came earlier
/// @audit event/error `ExceededMaxBuyAmount` came earlier
/// @audit event/error `NonIntegerDepositAmount` came earlier
/// @audit event/error `UnverifiedProof` came earlier
/// @audit event/error `PresaleUnavailable` came earlier
/// @audit event/error `InvalidPresaleStartTime` came earlier
/// @audit event/error `SaleNotOpen` came earlier
/// @audit event/error `InvalidFeeDefinition` came earlier
78:     mapping(address => address) public referralFeeDestination;

/// @audit event/error `Trade` came earlier
/// @audit event/error `Transfer` came earlier
/// @audit event/error `WhitelistUpdated` came earlier
/// @audit event/error `TokenDeployed` came earlier
/// @audit event/error `UnauthorizedCurvesTokenSubject` came earlier
/// @audit event/error `InsufficientPayment` came earlier
/// @audit event/error `CannotSendFunds` came earlier
/// @audit event/error `InsufficientBalance` came earlier
/// @audit event/error `InvalidERC20Metadata` came earlier
/// @audit event/error `ERC20TokenAlreadyMinted` came earlier
/// @audit event/error `TokenAbsentForCurvesTokenSubject` came earlier
/// @audit event/error `CurveAlreadyExists` came earlier
/// @audit event/error `LastTokenCannotBeSold` came earlier
/// @audit event/error `ContractCannotReceiveTransfer` came earlier
/// @audit event/error `ExceededMaxBuyAmount` came earlier
/// @audit event/error `NonIntegerDepositAmount` came earlier
/// @audit event/error `UnverifiedProof` came earlier
/// @audit event/error `PresaleUnavailable` came earlier
/// @audit event/error `InvalidPresaleStartTime` came earlier
/// @audit event/error `SaleNotOpen` came earlier
/// @audit event/error `InvalidFeeDefinition` came earlier
96:     mapping(address => mapping(address => uint256)) public curvesTokenBalance;

/// @audit event/error `Trade` came earlier
/// @audit event/error `Transfer` came earlier
/// @audit event/error `WhitelistUpdated` came earlier
/// @audit event/error `TokenDeployed` came earlier
/// @audit event/error `UnauthorizedCurvesTokenSubject` came earlier
/// @audit event/error `InsufficientPayment` came earlier
/// @audit event/error `CannotSendFunds` came earlier
/// @audit event/error `InsufficientBalance` came earlier
/// @audit event/error `InvalidERC20Metadata` came earlier
/// @audit event/error `ERC20TokenAlreadyMinted` came earlier
/// @audit event/error `TokenAbsentForCurvesTokenSubject` came earlier
/// @audit event/error `CurveAlreadyExists` came earlier
/// @audit event/error `LastTokenCannotBeSold` came earlier
/// @audit event/error `ContractCannotReceiveTransfer` came earlier
/// @audit event/error `ExceededMaxBuyAmount` came earlier
/// @audit event/error `NonIntegerDepositAmount` came earlier
/// @audit event/error `UnverifiedProof` came earlier
/// @audit event/error `PresaleUnavailable` came earlier
/// @audit event/error `InvalidPresaleStartTime` came earlier
/// @audit event/error `SaleNotOpen` came earlier
/// @audit event/error `InvalidFeeDefinition` came earlier
99:     mapping(address => uint256) public curvesTokenSupply;

/// @audit event/error `Trade` came earlier
/// @audit event/error `Transfer` came earlier
/// @audit event/error `WhitelistUpdated` came earlier
/// @audit event/error `TokenDeployed` came earlier
/// @audit event/error `UnauthorizedCurvesTokenSubject` came earlier
/// @audit event/error `InsufficientPayment` came earlier
/// @audit event/error `CannotSendFunds` came earlier
/// @audit event/error `InsufficientBalance` came earlier
/// @audit event/error `InvalidERC20Metadata` came earlier
/// @audit event/error `ERC20TokenAlreadyMinted` came earlier
/// @audit event/error `TokenAbsentForCurvesTokenSubject` came earlier
/// @audit event/error `CurveAlreadyExists` came earlier
/// @audit event/error `LastTokenCannotBeSold` came earlier
/// @audit event/error `ContractCannotReceiveTransfer` came earlier
/// @audit event/error `ExceededMaxBuyAmount` came earlier
/// @audit event/error `NonIntegerDepositAmount` came earlier
/// @audit event/error `UnverifiedProof` came earlier
/// @audit event/error `PresaleUnavailable` came earlier
/// @audit event/error `InvalidPresaleStartTime` came earlier
/// @audit event/error `SaleNotOpen` came earlier
/// @audit event/error `InvalidFeeDefinition` came earlier
101:     mapping(address => address[]) private ownedCurvesTokenSubjects;

```

```solidity
File: contracts/FeeSplitter.sol

/// @audit state variable `curves` came earlier
/// @audit state variable `PRECISION` came earlier
/// @audit event/error `NoFeesToClaim` came earlier
/// @audit event/error `NoTokenHolders` came earlier
17:     struct TokenData {

/// @audit state variable `curves` came earlier
/// @audit state variable `PRECISION` came earlier
/// @audit event/error `NoFeesToClaim` came earlier
/// @audit event/error `NoTokenHolders` came earlier
23:     struct UserClaimData {

/// @audit event/error `NoFeesToClaim` came earlier
/// @audit event/error `NoTokenHolders` came earlier
28:     mapping(address => TokenData) internal tokensData;

/// @audit event/error `NoFeesToClaim` came earlier
/// @audit event/error `NoTokenHolders` came earlier
29:     mapping(address => address[]) internal userTokens;

```

</details>


<a name="NC-11"></a> 
### [NC-11] Contract should expose an `interface`
All `external`/`public` functions should extend an `interface`. This is useful to make sure that the whole API is extracted.

*Note:* It is possible that the interface is out-of-scope and has not been seen by the bot.

<details>
<summary>
There are <b>41</b> instances (click to show):
</summary>

```solidity
File: contracts/Curves.sol

113:     function setFeeRedistributor(address feeRedistributor_) external onlyOwner {

117:     function setMaxFeePercent(uint256 maxFeePercent_) external onlyManager {

128:     function setProtocolFeePercent(uint256 protocolFeePercent_, address protocolFeeDestination_) external onlyOwner {

141:     function setExternalFeePercent(

155:     function setReferralFeeDestination(

162:     function setERC20Factory(address factory_) external onlyOwner {

166:     function getFees(

180:     function getPrice(uint256 supply, uint256 amount) public pure returns (uint256) {

189:     function getBuyPrice(address curvesTokenSubject, uint256 amount) public view returns (uint256) {

193:     function getSellPrice(address curvesTokenSubject, uint256 amount) public view returns (uint256) {

197:     function getBuyPriceAfterFee(address curvesTokenSubject, uint256 amount) public view returns (uint256) {

204:     function getSellPriceAfterFee(address curvesTokenSubject, uint256 amount) public view returns (uint256) {

211:     function buyCurvesToken(address curvesTokenSubject, uint256 amount) public payable {

282:     function sellCurvesToken(address curvesTokenSubject, uint256 amount) public {

296:     function transferCurvesToken(address curvesTokenSubject, address to, uint256 amount) external {

302:     function transferAllCurvesTokens(address to) external {

364:     function buyCurvesTokenWithName(

377:     function buyCurvesTokenForPresale(

394:     function setWhitelist(bytes32 merkleRoot) external {

404:     function buyCurvesTokenWhitelisted(

422:     function verifyMerkle(address curvesTokenSubject, address caller, bytes32[] memory proof) public view {

428:     function setNameAndSymbol(

439:     function mint(address curvesTokenSubject) external onlyTokenSubject(curvesTokenSubject) {

465:     function withdraw(address curvesTokenSubject, uint256 amount) public {

490:     function deposit(address curvesTokenSubject, uint256 amount) public {

504:     function sellExternalCurvesToken(address curvesTokenSubject, uint256 amount) public {

```

```solidity
File: contracts/CurvesERC20.sol

12:     function mint(address to, uint256 amount) public onlyOwner {

16:     function burn(address from, uint256 amount) public onlyOwner {

```

```solidity
File: contracts/CurvesERC20Factory.sol

7:     function deploy(string memory name, string memory symbol, address owner) public returns (address) {

```

```solidity
File: contracts/FeeSplitter.sol

35:     function setCurves(Curves curves_) public {

39:     function balanceOf(address token, address account) public view returns (uint256) {

43:     function totalSupply(address token) public view returns (uint256) {

48:     function getUserTokens(address user) public view returns (address[] memory) {

52:     function getUserTokensAndClaimable(address user) public view returns (UserClaimData[] memory) {

73:     function getClaimableFees(address token, address account) public view returns (uint256) {

80:     function claimFees(address token) external {

89:     function addFees(address token) public payable onlyManager {

96:     function onBalanceChange(address token, address account) public onlyManager {

103:     function batchClaiming(address[] calldata tokenList) external {

```

```solidity
File: contracts/Security.sol

23:     function setManager(address manager_, bool value) public onlyOwner {

27:     function transferOwnership(address owner_) public onlyOwner {

```

</details>


<a name="NC-12"></a> 
### [NC-12] Contracts should each be defined in separate files
Keeping each contract in a separate file makes it easier to work with multiple people, makes the code easier to maintain, and is a common practice on most projects. The following files each contains more than one contract/library/interface.

*There are <b>2</b> instances of this issue:*
```solidity
File: contracts/Curves.sol

/// @audit another contract/library/interface is defined in this file
13: interface CurvesErrors {

/// @audit another contract/library/interface is defined in this file
41: contract Curves is CurvesErrors, Security {

```


<a name="NC-13"></a> 
### [NC-13] Contracts should have full test coverage
While 100% code coverage does not guarantee that there are no bugs, it often will catch easy-to-find bugs, and will ensure that there are fewer regressions when the code invariably has to be modified. Furthermore, in order to get full coverage, code authors will often have to re-organize their code so that it is more modular, so that each component can be tested separately, which reduces interdependencies between modules and layers, and makes for code that is easier to reason about and audit.

*There is one instance of this issue:*
```solidity

Global finding

```


<a name="NC-14"></a> 
### [NC-14] Events that mark critical parameter changes should contain both the old and the new value
This should especially be done if the new value is not required to be different from the old value.

*There are <b>5</b> instances of this issue:*
```solidity
File: contracts/Curves.sol

324:         emit Transfer(curvesTokenSubject, from, to, amount);

360:         emit TokenDeployed(curvesTokenSubject, tokenContract, name, symbol);

400:             emit WhitelistUpdated(msg.sender, merkleRoot);

```

```solidity
File: contracts/FeeSplitter.sol

86:         emit FeesClaimed(token, msg.sender, claimable);

112:                 emit FeesClaimed(token, msg.sender, claimable);

```


<a name="NC-15"></a> 
### [NC-15] Custom errors has no error details
Consider adding parameters to the error to indicate which user or values caused the failure.

<details>
<summary>
There are <b>19</b> instances (click to show):
</summary>

```solidity
File: contracts/Curves.sol

15:     error UnauthorizedCurvesTokenSubject();

17:     error InsufficientPayment();

18:     error CannotSendFunds();

19:     error InsufficientBalance();

21:     error InvalidERC20Metadata();

22:     error ERC20TokenAlreadyMinted();

24:     error TokenAbsentForCurvesTokenSubject();

25:     error CurveAlreadyExists();

27:     error LastTokenCannotBeSold();

28:     error ContractCannotReceiveTransfer();

29:     error ExceededMaxBuyAmount();

30:     error NonIntegerDepositAmount();

32:     error UnverifiedProof();

34:     error PresaleUnavailable();

35:     error InvalidPresaleStartTime();

36:     error SaleNotOpen();

38:     error InvalidFeeDefinition();

```

```solidity
File: contracts/FeeSplitter.sol

14:     error NoFeesToClaim();

15:     error NoTokenHolders();

```

</details>


<a name="NC-16"></a> 
### [NC-16] Enable IR-based code generation
The IR-based code generator was introduced with an aim to not only allow code generation to be more transparent and auditable but also to enable more powerful optimization passes that span across functions. You can enable it on the command line using `--via-ir` or with the option `{"viaIR": true}`. This will take longer to compile, but you can just simple test it before deploying and if you got a better benchmark then you can add --via-ir to your deploy command More on: https://docs.soliditylang.org/en/v0.8.17/ir-breaking-changes.html

*There is one instance of this issue:*
```solidity

Global finding

```


<a name="NC-17"></a> 
### [NC-17] Events are emitted without the sender information
When an action is triggered based on a user's action, not being able to filter based on who triggered the action makes event processing a lot more cumbersome. Including the `msg.sender` the events of these types of action will make events much more useful to end users, especially when `msg.sender` is not `tx.origin`.

*There are <b>2</b> instances of this issue:*
```solidity
File: contracts/Curves.sol

324:         emit Transfer(curvesTokenSubject, from, to, amount);

360:         emit TokenDeployed(curvesTokenSubject, tokenContract, name, symbol);

```


<a name="NC-18"></a> 
### [NC-18] Events may be emitted out of order due to reentrancy
Ensure that events follow the best practice of check-effects-interaction, and are emitted before external calls.

*There is one instance of this issue:*
```solidity
File: contracts/Curves.sol

/// @audit `.onBalanceChange(...)` is called on line 247
251:         emit Trade(

```


<a name="NC-19"></a> 
### [NC-19] External call recipient can consume all remaining gas
There is no limit specified on the amount of gas used, so the recipient can use up all of the remaining gas (`gasleft()`), causing it to revert. Therefore, when calling an external contract, it is necessary to specify a limited amount of gas to forward.

*There is one instance of this issue:*
```solidity
File: contracts/Curves.sol

232:                 (bool success1, ) = firstDestination.call{value: isBuy ? buyValue : sellValue}("");

```


<a name="NC-20"></a> 
### [NC-20]  Function ordering does not follow the Solidity Style Guide
According to the [solidity style guide](https://docs.soliditylang.org/en/v0.8.17/style-guide.html#order-of-functions), functions should be laid out in the following order: `constructor()`, `receive()`, `fallback()`, `external`, `public`, `internal`, `private`, but the cases below do not follow this pattern

<details>
<summary>
There are <b>20</b> instances (click to show):
</summary>

```solidity
File: contracts/Curves.sol

/// @audit public function `setReferralFeeDestination` came earlier from this external function
162:     function setERC20Factory(address factory_) external onlyOwner {

/// @audit internal function `_transferFees` came earlier from this public function
/// @audit internal function `_buyCurvesToken` came earlier from this public function
282:     function sellCurvesToken(address curvesTokenSubject, uint256 amount) public {

/// @audit public function `setReferralFeeDestination` came earlier from this external function
/// @audit public function `getFees` came earlier from this external function
/// @audit public function `getPrice` came earlier from this external function
/// @audit public function `getBuyPrice` came earlier from this external function
/// @audit public function `getSellPrice` came earlier from this external function
/// @audit public function `getBuyPriceAfterFee` came earlier from this external function
/// @audit public function `getSellPriceAfterFee` came earlier from this external function
/// @audit public function `buyCurvesToken` came earlier from this external function
/// @audit internal function `_transferFees` came earlier from this external function
/// @audit internal function `_buyCurvesToken` came earlier from this external function
/// @audit public function `sellCurvesToken` came earlier from this external function
296:     function transferCurvesToken(address curvesTokenSubject, address to, uint256 amount) external {

/// @audit public function `setReferralFeeDestination` came earlier from this external function
/// @audit public function `getFees` came earlier from this external function
/// @audit public function `getPrice` came earlier from this external function
/// @audit public function `getBuyPrice` came earlier from this external function
/// @audit public function `getSellPrice` came earlier from this external function
/// @audit public function `getBuyPriceAfterFee` came earlier from this external function
/// @audit public function `getSellPriceAfterFee` came earlier from this external function
/// @audit public function `buyCurvesToken` came earlier from this external function
/// @audit internal function `_transferFees` came earlier from this external function
/// @audit internal function `_buyCurvesToken` came earlier from this external function
/// @audit public function `sellCurvesToken` came earlier from this external function
302:     function transferAllCurvesTokens(address to) external {

/// @audit internal function `_transferFees` came earlier from this public function
/// @audit internal function `_buyCurvesToken` came earlier from this public function
/// @audit internal function `_transfer` came earlier from this public function
/// @audit internal function `_addOwnedCurvesTokenSubject` came earlier from this public function
/// @audit internal function `_deployERC20` came earlier from this public function
364:     function buyCurvesTokenWithName(

/// @audit internal function `_transferFees` came earlier from this public function
/// @audit internal function `_buyCurvesToken` came earlier from this public function
/// @audit internal function `_transfer` came earlier from this public function
/// @audit internal function `_addOwnedCurvesTokenSubject` came earlier from this public function
/// @audit internal function `_deployERC20` came earlier from this public function
377:     function buyCurvesTokenForPresale(

/// @audit public function `setReferralFeeDestination` came earlier from this external function
/// @audit public function `getFees` came earlier from this external function
/// @audit public function `getPrice` came earlier from this external function
/// @audit public function `getBuyPrice` came earlier from this external function
/// @audit public function `getSellPrice` came earlier from this external function
/// @audit public function `getBuyPriceAfterFee` came earlier from this external function
/// @audit public function `getSellPriceAfterFee` came earlier from this external function
/// @audit public function `buyCurvesToken` came earlier from this external function
/// @audit internal function `_transferFees` came earlier from this external function
/// @audit internal function `_buyCurvesToken` came earlier from this external function
/// @audit public function `sellCurvesToken` came earlier from this external function
/// @audit internal function `_transfer` came earlier from this external function
/// @audit internal function `_addOwnedCurvesTokenSubject` came earlier from this external function
/// @audit internal function `_deployERC20` came earlier from this external function
/// @audit public function `buyCurvesTokenWithName` came earlier from this external function
/// @audit public function `buyCurvesTokenForPresale` came earlier from this external function
394:     function setWhitelist(bytes32 merkleRoot) external {

/// @audit internal function `_transferFees` came earlier from this public function
/// @audit internal function `_buyCurvesToken` came earlier from this public function
/// @audit internal function `_transfer` came earlier from this public function
/// @audit internal function `_addOwnedCurvesTokenSubject` came earlier from this public function
/// @audit internal function `_deployERC20` came earlier from this public function
404:     function buyCurvesTokenWhitelisted(

/// @audit internal function `_transferFees` came earlier from this public function
/// @audit internal function `_buyCurvesToken` came earlier from this public function
/// @audit internal function `_transfer` came earlier from this public function
/// @audit internal function `_addOwnedCurvesTokenSubject` came earlier from this public function
/// @audit internal function `_deployERC20` came earlier from this public function
422:     function verifyMerkle(address curvesTokenSubject, address caller, bytes32[] memory proof) public view {

/// @audit public function `setReferralFeeDestination` came earlier from this external function
/// @audit public function `getFees` came earlier from this external function
/// @audit public function `getPrice` came earlier from this external function
/// @audit public function `getBuyPrice` came earlier from this external function
/// @audit public function `getSellPrice` came earlier from this external function
/// @audit public function `getBuyPriceAfterFee` came earlier from this external function
/// @audit public function `getSellPriceAfterFee` came earlier from this external function
/// @audit public function `buyCurvesToken` came earlier from this external function
/// @audit internal function `_transferFees` came earlier from this external function
/// @audit internal function `_buyCurvesToken` came earlier from this external function
/// @audit public function `sellCurvesToken` came earlier from this external function
/// @audit internal function `_transfer` came earlier from this external function
/// @audit internal function `_addOwnedCurvesTokenSubject` came earlier from this external function
/// @audit internal function `_deployERC20` came earlier from this external function
/// @audit public function `buyCurvesTokenWithName` came earlier from this external function
/// @audit public function `buyCurvesTokenForPresale` came earlier from this external function
/// @audit public function `buyCurvesTokenWhitelisted` came earlier from this external function
/// @audit public function `verifyMerkle` came earlier from this external function
428:     function setNameAndSymbol(

/// @audit public function `setReferralFeeDestination` came earlier from this external function
/// @audit public function `getFees` came earlier from this external function
/// @audit public function `getPrice` came earlier from this external function
/// @audit public function `getBuyPrice` came earlier from this external function
/// @audit public function `getSellPrice` came earlier from this external function
/// @audit public function `getBuyPriceAfterFee` came earlier from this external function
/// @audit public function `getSellPriceAfterFee` came earlier from this external function
/// @audit public function `buyCurvesToken` came earlier from this external function
/// @audit internal function `_transferFees` came earlier from this external function
/// @audit internal function `_buyCurvesToken` came earlier from this external function
/// @audit public function `sellCurvesToken` came earlier from this external function
/// @audit internal function `_transfer` came earlier from this external function
/// @audit internal function `_addOwnedCurvesTokenSubject` came earlier from this external function
/// @audit internal function `_deployERC20` came earlier from this external function
/// @audit public function `buyCurvesTokenWithName` came earlier from this external function
/// @audit public function `buyCurvesTokenForPresale` came earlier from this external function
/// @audit public function `buyCurvesTokenWhitelisted` came earlier from this external function
/// @audit public function `verifyMerkle` came earlier from this external function
439:     function mint(address curvesTokenSubject) external onlyTokenSubject(curvesTokenSubject) {

/// @audit internal function `_transferFees` came earlier from this public function
/// @audit internal function `_buyCurvesToken` came earlier from this public function
/// @audit internal function `_transfer` came earlier from this public function
/// @audit internal function `_addOwnedCurvesTokenSubject` came earlier from this public function
/// @audit internal function `_deployERC20` came earlier from this public function
/// @audit internal function `_mint` came earlier from this public function
465:     function withdraw(address curvesTokenSubject, uint256 amount) public {

/// @audit internal function `_transferFees` came earlier from this public function
/// @audit internal function `_buyCurvesToken` came earlier from this public function
/// @audit internal function `_transfer` came earlier from this public function
/// @audit internal function `_addOwnedCurvesTokenSubject` came earlier from this public function
/// @audit internal function `_deployERC20` came earlier from this public function
/// @audit internal function `_mint` came earlier from this public function
490:     function deposit(address curvesTokenSubject, uint256 amount) public {

/// @audit internal function `_transferFees` came earlier from this public function
/// @audit internal function `_buyCurvesToken` came earlier from this public function
/// @audit internal function `_transfer` came earlier from this public function
/// @audit internal function `_addOwnedCurvesTokenSubject` came earlier from this public function
/// @audit internal function `_deployERC20` came earlier from this public function
/// @audit internal function `_mint` came earlier from this public function
504:     function sellExternalCurvesToken(address curvesTokenSubject, uint256 amount) public {

```

```solidity
File: contracts/FeeSplitter.sol

/// @audit internal function `updateFeeCredit` came earlier from this public function
73:     function getClaimableFees(address token, address account) public view returns (uint256) {

/// @audit public function `setCurves` came earlier from this external function
/// @audit public function `balanceOf` came earlier from this external function
/// @audit public function `totalSupply` came earlier from this external function
/// @audit public function `getUserTokens` came earlier from this external function
/// @audit public function `getUserTokensAndClaimable` came earlier from this external function
/// @audit internal function `updateFeeCredit` came earlier from this external function
/// @audit public function `getClaimableFees` came earlier from this external function
80:     function claimFees(address token) external {

/// @audit internal function `updateFeeCredit` came earlier from this public function
89:     function addFees(address token) public payable onlyManager {

/// @audit internal function `updateFeeCredit` came earlier from this public function
96:     function onBalanceChange(address token, address account) public onlyManager {

/// @audit public function `setCurves` came earlier from this external function
/// @audit public function `balanceOf` came earlier from this external function
/// @audit public function `totalSupply` came earlier from this external function
/// @audit public function `getUserTokens` came earlier from this external function
/// @audit public function `getUserTokensAndClaimable` came earlier from this external function
/// @audit internal function `updateFeeCredit` came earlier from this external function
/// @audit public function `getClaimableFees` came earlier from this external function
/// @audit public function `addFees` came earlier from this external function
/// @audit public function `onBalanceChange` came earlier from this external function
103:     function batchClaiming(address[] calldata tokenList) external {

/// @audit a function was seen before receive()
/// @audit a function was seen before receive()
/// @audit a function was seen before receive()
/// @audit a function was seen before receive()
/// @audit a function was seen before receive()
/// @audit a function was seen before receive()
/// @audit a function was seen before receive()
/// @audit a function was seen before receive()
/// @audit a function was seen before receive()
/// @audit a function was seen before receive()
/// @audit a function was seen before receive()
119:     receive() external payable {}

```

</details>


<a name="NC-21"></a> 
### [NC-21] Functions with array parameters should have length checks in place

*There are <b>3</b> instances of this issue:*
```solidity
File: contracts/Curves.sol

/// @audit `proof`
404:     function buyCurvesTokenWhitelisted(

/// @audit `proof`
422:     function verifyMerkle(address curvesTokenSubject, address caller, bytes32[] memory proof) public view {

```

```solidity
File: contracts/FeeSplitter.sol

/// @audit `tokenList`
103:     function batchClaiming(address[] calldata tokenList) external {

```


<a name="NC-22"></a> 
### [NC-22] High cyclomatic complexity
Consider breaking down these blocks into more manageable units, by splitting things into utility functions, by reducing nesting, and by using early returns

*There is one instance of this issue:*
```solidity
File: contracts/Curves.sol

/// @audit Number of blocks: 10
218:     function _transferFees(

```


<a name="NC-23"></a> 
### [NC-23] Import declarations should import specific identifiers, rather than the whole file
Using import declarations of the form `import {<identifier_name>} from "some/file.sol"` avoids polluting the symbol namespace making flattened files smaller, and speeds up compilation (but does not save any gas).

<details>
<summary>
There are <b>12</b> instances (click to show):
</summary>

```solidity
File: contracts/Curves.sol

4: import "@openzeppelin/contracts/utils/Strings.sol";

5: import "@openzeppelin/contracts/utils/cryptography/MerkleProof.sol";

7: import "./CurvesERC20.sol";

8: import "./CurvesERC20Factory.sol";

10: import "./FeeSplitter.sol";

11: import "./Security.sol";

```

```solidity
File: contracts/CurvesERC20.sol

4: import "@openzeppelin/contracts/access/Ownable.sol";

5: import "@openzeppelin/contracts/token/ERC20/ERC20.sol";

```

```solidity
File: contracts/CurvesERC20Factory.sol

4: import "./CurvesERC20.sol";

```

```solidity
File: contracts/FeeSplitter.sol

4: import "./Curves.sol";

5: import "./Security.sol";

7: import "@openzeppelin/contracts/token/ERC20/IERC20.sol";

```

</details>


<a name="NC-24"></a> 
### [NC-24] Imports could be organized more systematically
The contract's interface should be imported first, followed by each of the interfaces it uses, followed by all other files. The examples below do not follow this layout.

*There is one instance of this issue:*
```solidity
File: contracts/FeeSplitter.sol

7: import "@openzeppelin/contracts/token/ERC20/IERC20.sol";

```


<a name="NC-25"></a> 
### [NC-25] Inconsistent spacing in comments
Some lines use `// x` and some use `//x`. The instances below point out the usages that don't follow the majority, within each file

*There are <b>2</b> instances of this issue:*
```solidity
File: contracts/FeeSplitter.sol

44:         //@dev: this is the amount of tokens that are not locked in the contract. The locked tokens are in the ERC20 contract

102:     //@dev: this may fail if the the list is long. Get first the list with getUserTokens to estimate and prepare the batch

```


<a name="NC-26"></a> 
### [NC-26] Interfaces should have an `I` prefix in the contract name
As a best practice, any `interface` should have an `I` as a prefix in their contract name.

*There is one instance of this issue:*
```solidity
File: contracts/Curves.sol

13: interface CurvesErrors {

```


<a name="NC-27"></a> 
### [NC-27] Invalid NatSpec comment style
NatSpec must begin with `///` or use `/* ... */` syntax

*There are <b>2</b> instances of this issue:*
```solidity
File: contracts/FeeSplitter.sol

44:         //@dev: this is the amount of tokens that are not locked in the contract. The locked tokens are in the ERC20 contract

102:     //@dev: this may fail if the the list is long. Get first the list with getUserTokens to estimate and prepare the batch

```


<a name="NC-28"></a> 
### [NC-28] Large or complicated code bases should implement invariant tests
This includes: large code bases, or code with lots of inline-assembly, complicated math, or complicated interactions between multiple contracts. Invariant fuzzers such as Echidna require the test writer to come up with invariants which should not be violated under any circumstances, and the fuzzer tests various inputs and function calls to ensure that the invariants always hold. Even code with 100% code coverage can still have bugs due to the order of the operations a user performs, and invariant fuzzers may help significantly.

*There is one instance of this issue:*
```solidity

Global finding

```


<a name="NC-29"></a> 
### [NC-29] Large numeric literals should use underscores for readability
Large hardcoded numbers in code can be difficult to read. Consider using underscores for number literals to improve readability (e.g `1234567` -> `1_234_567`). Consider using an underscore for every third digit from the right.

*There is one instance of this issue:*
```solidity
File: contracts/Curves.sol

186:         return (summation * 1 ether) / 16000;

```


<a name="NC-30"></a> 
### [NC-30] Magic numbers should be replaced with constants
Magic numbers are hard-coded values in code that can make it difficult for developers and maintainers to understand the code, and can also cause confusion or errors. To improve the readability and maintainability of code, it is recommended to replace magic numbers with constants that have good readability.

*There are <b>5</b> instances of this issue:*
```solidity
File: contracts/Curves.sol

// @audit `2`
181:         uint256 sum1 = supply == 0 ? 0 : ((supply - 1) * (supply) * (2 * (supply - 1) + 1)) / 6;

// @audit `6`
181:         uint256 sum1 = supply == 0 ? 0 : ((supply - 1) * (supply) * (2 * (supply - 1) + 1)) / 6;

// @audit `2`
184:             : ((supply - 1 + amount) * (supply + amount) * (2 * (supply - 1 + amount) + 1)) / 6;

// @audit `6`
184:             : ((supply - 1 + amount) * (supply + amount) * (2 * (supply - 1 + amount) + 1)) / 6;

// @audit `16000`
186:         return (summation * 1 ether) / 16000;

```


<a name="NC-31"></a> 
### [NC-31] Missing contract existence checks before low-level calls
Low-level calls return success if there is no code present at the specified address. In addition to the zero-address checks, add a check to verify that `<address>.code.length > 0`

*There is one instance of this issue:*
```solidity
File: contracts/Curves.sol

232:                 (bool success1, ) = firstDestination.call{value: isBuy ? buyValue : sellValue}("");

```


<a name="NC-32"></a> 
### [NC-32] Named mappings are recommended
[Named mappings](https://docs.soliditylang.org/en/v0.8.18/types.html#mapping-types) (with syntax `mapping(KeyType KeyName? => ValueType ValueName?)`) are recommended.It can make the mapping variables clearer, more readable and easier to maintain.

<details>
<summary>
There are <b>14</b> instances (click to show):
</summary>

```solidity
File: contracts/Curves.sol

61:     mapping(address => ExternalTokenMeta) public externalCurvesTokens;

62:     mapping(address => address) public externalCurvesToSubject;

63:     mapping(string => address) public symbolToSubject;

65:     mapping(address => PresaleMeta) public presalesMeta;

66:     mapping(address => mapping(address => uint256)) public presalesBuys;

78:     mapping(address => address) public referralFeeDestination;

96:     mapping(address => mapping(address => uint256)) public curvesTokenBalance;

99:     mapping(address => uint256) public curvesTokenSupply;

101:     mapping(address => address[]) private ownedCurvesTokenSubjects;

```

```solidity
File: contracts/FeeSplitter.sol

19:         mapping(address => uint256) userFeeOffset;

20:         mapping(address => uint256) unclaimedFees;

28:     mapping(address => TokenData) internal tokensData;

29:     mapping(address => address[]) internal userTokens;

```

```solidity
File: contracts/Security.sol

6:     mapping(address => bool) public managers;

```

</details>


<a name="NC-33"></a> 
### [NC-33] Named imports of parent contracts are missing

*There are <b>3</b> instances of this issue:*
```solidity
File: contracts/Curves.sol

/// @audit `CurvesErrors`
/// @audit `Security`
41: contract Curves is CurvesErrors, Security {

```

```solidity
File: contracts/CurvesERC20.sol

/// @audit `ERC20`
/// @audit `Ownable`
7: contract CurvesERC20 is ERC20, Ownable {

```

```solidity
File: contracts/FeeSplitter.sol

/// @audit `Security`
9: contract FeeSplitter is Security {

```


<a name="NC-34"></a> 
### [NC-34] Missing NatSpec from contract declarations
e.g. `@dev` or `@notice`, and it must appear above the contract definition braces in order to be identified by the compiler as NatSpec.

*There are <b>6</b> instances of this issue:*
```solidity
File: contracts/Curves.sol

13: interface CurvesErrors {

41: contract Curves is CurvesErrors, Security {

```

```solidity
File: contracts/CurvesERC20.sol

7: contract CurvesERC20 is ERC20, Ownable {

```

```solidity
File: contracts/CurvesERC20Factory.sol

6: contract CurvesERC20Factory {

```

```solidity
File: contracts/FeeSplitter.sol

9: contract FeeSplitter is Security {

```

```solidity
File: contracts/Security.sol

4: contract Security {

```


<a name="NC-35"></a> 
### [NC-35] Missing NatSpec `@author` from contract declaration
Some contract definitions have an incomplete NatSpec: add a `@author` notation to improve the code documentation.

*There are <b>6</b> instances of this issue:*
```solidity
File: contracts/Curves.sol

13: interface CurvesErrors {

41: contract Curves is CurvesErrors, Security {

```

```solidity
File: contracts/CurvesERC20.sol

7: contract CurvesERC20 is ERC20, Ownable {

```

```solidity
File: contracts/CurvesERC20Factory.sol

6: contract CurvesERC20Factory {

```

```solidity
File: contracts/FeeSplitter.sol

9: contract FeeSplitter is Security {

```

```solidity
File: contracts/Security.sol

4: contract Security {

```


<a name="NC-36"></a> 
### [NC-36] Missing NatSpec `@dev` from contract declaration
Some contract definitions have an incomplete NatSpec: add a `@dev` notation to improve the code documentation.

*There are <b>6</b> instances of this issue:*
```solidity
File: contracts/Curves.sol

13: interface CurvesErrors {

41: contract Curves is CurvesErrors, Security {

```

```solidity
File: contracts/CurvesERC20.sol

7: contract CurvesERC20 is ERC20, Ownable {

```

```solidity
File: contracts/CurvesERC20Factory.sol

6: contract CurvesERC20Factory {

```

```solidity
File: contracts/FeeSplitter.sol

9: contract FeeSplitter is Security {

```

```solidity
File: contracts/Security.sol

4: contract Security {

```


<a name="NC-37"></a> 
### [NC-37] Missing NatSpec `@dev` from event declaration
Some event definitions have an incomplete NatSpec: add a `@dev` notation to improve the code documentation.

*There are <b>5</b> instances of this issue:*
```solidity
File: contracts/Curves.sol

80:     event Trade(

91:     event Transfer(address indexed curvesTokenSubject, address indexed from, address indexed to, uint256 value);

92:     event WhitelistUpdated(address indexed presale, bytes32 indexed root);

93:     event TokenDeployed(address indexed curvesTokenSubject, address indexed erc20token, string name, string symbol);

```

```solidity
File: contracts/FeeSplitter.sol

31:     event FeesClaimed(address indexed token, address indexed user, uint256 amount);

```


<a name="NC-38"></a> 
### [NC-38] Missing NatSpec `@dev` from function declaration
Some function definitions have an incomplete NatSpec: add a `@dev` notation to improve the code documentation.

<details>
<summary>
There are <b>53</b> instances (click to show):
</summary>

```solidity
File: contracts/Curves.sol

108:     constructor(address curvesERC20Factory_, address feeRedistributor_) Security() {

113:     function setFeeRedistributor(address feeRedistributor_) external onlyOwner {

117:     function setMaxFeePercent(uint256 maxFeePercent_) external onlyManager {

128:     function setProtocolFeePercent(uint256 protocolFeePercent_, address protocolFeeDestination_) external onlyOwner {

141:     function setExternalFeePercent(

155:     function setReferralFeeDestination(

162:     function setERC20Factory(address factory_) external onlyOwner {

166:     function getFees(

180:     function getPrice(uint256 supply, uint256 amount) public pure returns (uint256) {

189:     function getBuyPrice(address curvesTokenSubject, uint256 amount) public view returns (uint256) {

193:     function getSellPrice(address curvesTokenSubject, uint256 amount) public view returns (uint256) {

197:     function getBuyPriceAfterFee(address curvesTokenSubject, uint256 amount) public view returns (uint256) {

204:     function getSellPriceAfterFee(address curvesTokenSubject, uint256 amount) public view returns (uint256) {

211:     function buyCurvesToken(address curvesTokenSubject, uint256 amount) public payable {

218:     function _transferFees(

263:     function _buyCurvesToken(address curvesTokenSubject, uint256 amount) internal {

282:     function sellCurvesToken(address curvesTokenSubject, uint256 amount) public {

296:     function transferCurvesToken(address curvesTokenSubject, address to, uint256 amount) external {

302:     function transferAllCurvesTokens(address to) external {

313:     function _transfer(address curvesTokenSubject, address from, address to, uint256 amount) internal {

328:     function _addOwnedCurvesTokenSubject(address owner_, address curvesTokenSubject) internal {

338:     function _deployERC20(

364:     function buyCurvesTokenWithName(

377:     function buyCurvesTokenForPresale(

394:     function setWhitelist(bytes32 merkleRoot) external {

404:     function buyCurvesTokenWhitelisted(

422:     function verifyMerkle(address curvesTokenSubject, address caller, bytes32[] memory proof) public view {

428:     function setNameAndSymbol(

439:     function mint(address curvesTokenSubject) external onlyTokenSubject(curvesTokenSubject) {

456:     function _mint(

465:     function withdraw(address curvesTokenSubject, uint256 amount) public {

490:     function deposit(address curvesTokenSubject, uint256 amount) public {

504:     function sellExternalCurvesToken(address curvesTokenSubject, uint256 amount) public {

```

```solidity
File: contracts/CurvesERC20.sol

8:     constructor(string memory name_, string memory symbol_, address owner) ERC20(name_, symbol_) {

12:     function mint(address to, uint256 amount) public onlyOwner {

16:     function burn(address from, uint256 amount) public onlyOwner {

```

```solidity
File: contracts/CurvesERC20Factory.sol

7:     function deploy(string memory name, string memory symbol, address owner) public returns (address) {

```

```solidity
File: contracts/FeeSplitter.sol

33:     constructor() Security() {}

35:     function setCurves(Curves curves_) public {

39:     function balanceOf(address token, address account) public view returns (uint256) {

43:     function totalSupply(address token) public view returns (uint256) {

48:     function getUserTokens(address user) public view returns (address[] memory) {

52:     function getUserTokensAndClaimable(address user) public view returns (UserClaimData[] memory) {

63:     function updateFeeCredit(address token, address account) internal {

73:     function getClaimableFees(address token, address account) public view returns (uint256) {

80:     function claimFees(address token) external {

89:     function addFees(address token) public payable onlyManager {

96:     function onBalanceChange(address token, address account) public onlyManager {

103:     function batchClaiming(address[] calldata tokenList) external {

119:     receive() external payable {}

```

```solidity
File: contracts/Security.sol

18:     constructor() {

23:     function setManager(address manager_, bool value) public onlyOwner {

27:     function transferOwnership(address owner_) public onlyOwner {

```

</details>


<a name="NC-39"></a> 
### [NC-39] Missing NatSpec `@dev` from modifier declaration
Some modifier definitions have an incomplete NatSpec: add a `@dev` notation to improve the code documentation.

*There are <b>3</b> instances of this issue:*
```solidity
File: contracts/Curves.sol

103:     modifier onlyTokenSubject(address curvesTokenSubject) {

```

```solidity
File: contracts/Security.sol

8:     modifier onlyOwner() {

13:     modifier onlyManager() {

```


<a name="NC-40"></a> 
### [NC-40] Error declarations should have NatSpec descriptions

<details>
<summary>
There are <b>19</b> instances (click to show):
</summary>

```solidity
File: contracts/Curves.sol

15:     error UnauthorizedCurvesTokenSubject();

17:     error InsufficientPayment();

18:     error CannotSendFunds();

19:     error InsufficientBalance();

21:     error InvalidERC20Metadata();

22:     error ERC20TokenAlreadyMinted();

24:     error TokenAbsentForCurvesTokenSubject();

25:     error CurveAlreadyExists();

27:     error LastTokenCannotBeSold();

28:     error ContractCannotReceiveTransfer();

29:     error ExceededMaxBuyAmount();

30:     error NonIntegerDepositAmount();

32:     error UnverifiedProof();

34:     error PresaleUnavailable();

35:     error InvalidPresaleStartTime();

36:     error SaleNotOpen();

38:     error InvalidFeeDefinition();

```

```solidity
File: contracts/FeeSplitter.sol

14:     error NoFeesToClaim();

15:     error NoTokenHolders();

```

</details>


<a name="NC-41"></a> 
### [NC-41] Event declarations should have NatSpec descriptions

*There are <b>5</b> instances of this issue:*
```solidity
File: contracts/Curves.sol

80:     event Trade(

91:     event Transfer(address indexed curvesTokenSubject, address indexed from, address indexed to, uint256 value);

92:     event WhitelistUpdated(address indexed presale, bytes32 indexed root);

93:     event TokenDeployed(address indexed curvesTokenSubject, address indexed erc20token, string name, string symbol);

```

```solidity
File: contracts/FeeSplitter.sol

31:     event FeesClaimed(address indexed token, address indexed user, uint256 amount);

```


<a name="NC-42"></a> 
### [NC-42] NatSpec documentation for function is missing
It is recommended that Solidity contracts are fully annotated using NatSpec for all public interfaces (everything in the ABI). It is clearly stated in the Solidity official documentation. In complex projects such as DeFi, the interpretation of all functions and their arguments and returns is important for code readability and auditability.

<details>
<summary>
There are <b>53</b> instances (click to show):
</summary>

```solidity
File: contracts/Curves.sol

108:     constructor(address curvesERC20Factory_, address feeRedistributor_) Security() {

113:     function setFeeRedistributor(address feeRedistributor_) external onlyOwner {

117:     function setMaxFeePercent(uint256 maxFeePercent_) external onlyManager {

128:     function setProtocolFeePercent(uint256 protocolFeePercent_, address protocolFeeDestination_) external onlyOwner {

141:     function setExternalFeePercent(
             uint256 subjectFeePercent_,
             uint256 referralFeePercent_,
             uint256 holdersFeePercent_
         ) external onlyManager {

155:     function setReferralFeeDestination(
             address curvesTokenSubject,
             address referralFeeDestination_
         ) public onlyTokenSubject(curvesTokenSubject) {

162:     function setERC20Factory(address factory_) external onlyOwner {

166:     function getFees(
             uint256 price
         )
             public
             view
             returns (uint256 protocolFee, uint256 subjectFee, uint256 referralFee, uint256 holdersFee, uint256 totalFee)
         {

180:     function getPrice(uint256 supply, uint256 amount) public pure returns (uint256) {

189:     function getBuyPrice(address curvesTokenSubject, uint256 amount) public view returns (uint256) {

193:     function getSellPrice(address curvesTokenSubject, uint256 amount) public view returns (uint256) {

197:     function getBuyPriceAfterFee(address curvesTokenSubject, uint256 amount) public view returns (uint256) {

204:     function getSellPriceAfterFee(address curvesTokenSubject, uint256 amount) public view returns (uint256) {

211:     function buyCurvesToken(address curvesTokenSubject, uint256 amount) public payable {

218:     function _transferFees(
             address curvesTokenSubject,
             bool isBuy,
             uint256 price,
             uint256 amount,
             uint256 supply
         ) internal {

263:     function _buyCurvesToken(address curvesTokenSubject, uint256 amount) internal {

282:     function sellCurvesToken(address curvesTokenSubject, uint256 amount) public {

296:     function transferCurvesToken(address curvesTokenSubject, address to, uint256 amount) external {

302:     function transferAllCurvesTokens(address to) external {

313:     function _transfer(address curvesTokenSubject, address from, address to, uint256 amount) internal {

328:     function _addOwnedCurvesTokenSubject(address owner_, address curvesTokenSubject) internal {

338:     function _deployERC20(
             address curvesTokenSubject,
             string memory name,
             string memory symbol
         ) internal returns (address) {

364:     function buyCurvesTokenWithName(
             address curvesTokenSubject,
             uint256 amount,
             string memory name,
             string memory symbol
         ) public payable {

377:     function buyCurvesTokenForPresale(
             address curvesTokenSubject,
             uint256 amount,
             uint256 startTime,
             bytes32 merkleRoot,
             uint256 maxBuy
         ) public payable onlyTokenSubject(curvesTokenSubject) {

394:     function setWhitelist(bytes32 merkleRoot) external {

404:     function buyCurvesTokenWhitelisted(
             address curvesTokenSubject,
             uint256 amount,
             bytes32[] memory proof
         ) public payable {

422:     function verifyMerkle(address curvesTokenSubject, address caller, bytes32[] memory proof) public view {

428:     function setNameAndSymbol(
             address curvesTokenSubject,
             string memory name,
             string memory symbol
         ) external onlyTokenSubject(curvesTokenSubject) {

439:     function mint(address curvesTokenSubject) external onlyTokenSubject(curvesTokenSubject) {

456:     function _mint(
             address curvesTokenSubject,
             string memory name,
             string memory symbol
         ) internal onlyTokenSubject(curvesTokenSubject) {

465:     function withdraw(address curvesTokenSubject, uint256 amount) public {

490:     function deposit(address curvesTokenSubject, uint256 amount) public {

504:     function sellExternalCurvesToken(address curvesTokenSubject, uint256 amount) public {

```

```solidity
File: contracts/CurvesERC20.sol

8:     constructor(string memory name_, string memory symbol_, address owner) ERC20(name_, symbol_) {

12:     function mint(address to, uint256 amount) public onlyOwner {

16:     function burn(address from, uint256 amount) public onlyOwner {

```

```solidity
File: contracts/CurvesERC20Factory.sol

7:     function deploy(string memory name, string memory symbol, address owner) public returns (address) {

```

```solidity
File: contracts/FeeSplitter.sol

33:     constructor() Security() {}

35:     function setCurves(Curves curves_) public {

39:     function balanceOf(address token, address account) public view returns (uint256) {

43:     function totalSupply(address token) public view returns (uint256) {

48:     function getUserTokens(address user) public view returns (address[] memory) {

52:     function getUserTokensAndClaimable(address user) public view returns (UserClaimData[] memory) {

63:     function updateFeeCredit(address token, address account) internal {

73:     function getClaimableFees(address token, address account) public view returns (uint256) {

80:     function claimFees(address token) external {

89:     function addFees(address token) public payable onlyManager {

96:     function onBalanceChange(address token, address account) public onlyManager {

103:     function batchClaiming(address[] calldata tokenList) external {

119:     receive() external payable {}

```

```solidity
File: contracts/Security.sol

18:     constructor() {

23:     function setManager(address manager_, bool value) public onlyOwner {

27:     function transferOwnership(address owner_) public onlyOwner {

```

</details>


<a name="NC-43"></a> 
### [NC-43] Modifier declarations should have NatSpec descriptions

*There are <b>3</b> instances of this issue:*
```solidity
File: contracts/Curves.sol

103:     modifier onlyTokenSubject(address curvesTokenSubject) {

```

```solidity
File: contracts/Security.sol

8:     modifier onlyOwner() {

13:     modifier onlyManager() {

```


<a name="NC-44"></a> 
### [NC-44] Public variable declarations should have NatSpec descriptions

<details>
<summary>
There are <b>16</b> instances (click to show):
</summary>

```solidity
File: contracts/Curves.sol

42:     address public curvesERC20Factory;

43:     FeeSplitter public feeRedistributor;

44:     string public constant DEFAULT_NAME = "Curves";

45:     string public constant DEFAULT_SYMBOL = "CURVES";

61:     mapping(address => ExternalTokenMeta) public externalCurvesTokens;

62:     mapping(address => address) public externalCurvesToSubject;

63:     mapping(string => address) public symbolToSubject;

65:     mapping(address => PresaleMeta) public presalesMeta;

66:     mapping(address => mapping(address => uint256)) public presalesBuys;

77:     FeesEconomics public feesEconomics;

78:     mapping(address => address) public referralFeeDestination;

96:     mapping(address => mapping(address => uint256)) public curvesTokenBalance;

99:     mapping(address => uint256) public curvesTokenSupply;

```

```solidity
File: contracts/FeeSplitter.sol

10:     Curves public curves;

```

```solidity
File: contracts/Security.sol

5:     address public owner;

6:     mapping(address => bool) public managers;

```

</details>


<a name="NC-45"></a> 
### [NC-45] Missing NatSpec `@notice` from contract declaration
Some contract definitions have an incomplete NatSpec: add a `@notice` notation to improve the code documentation.

*There are <b>6</b> instances of this issue:*
```solidity
File: contracts/Curves.sol

13: interface CurvesErrors {

41: contract Curves is CurvesErrors, Security {

```

```solidity
File: contracts/CurvesERC20.sol

7: contract CurvesERC20 is ERC20, Ownable {

```

```solidity
File: contracts/CurvesERC20Factory.sol

6: contract CurvesERC20Factory {

```

```solidity
File: contracts/FeeSplitter.sol

9: contract FeeSplitter is Security {

```

```solidity
File: contracts/Security.sol

4: contract Security {

```


<a name="NC-46"></a> 
### [NC-46] Missing NatSpec `@notice` from event declaration
Some event definitions have an incomplete NatSpec: add a `@notice` notation to improve the code documentation.

*There are <b>5</b> instances of this issue:*
```solidity
File: contracts/Curves.sol

80:     event Trade(

91:     event Transfer(address indexed curvesTokenSubject, address indexed from, address indexed to, uint256 value);

92:     event WhitelistUpdated(address indexed presale, bytes32 indexed root);

93:     event TokenDeployed(address indexed curvesTokenSubject, address indexed erc20token, string name, string symbol);

```

```solidity
File: contracts/FeeSplitter.sol

31:     event FeesClaimed(address indexed token, address indexed user, uint256 amount);

```


<a name="NC-47"></a> 
### [NC-47] Missing NatSpec `@notice` from function declaration
Some function definitions have an incomplete NatSpec: add a `@notice` notation to improve the code documentation.

<details>
<summary>
There are <b>53</b> instances (click to show):
</summary>

```solidity
File: contracts/Curves.sol

108:     constructor(address curvesERC20Factory_, address feeRedistributor_) Security() {

113:     function setFeeRedistributor(address feeRedistributor_) external onlyOwner {

117:     function setMaxFeePercent(uint256 maxFeePercent_) external onlyManager {

128:     function setProtocolFeePercent(uint256 protocolFeePercent_, address protocolFeeDestination_) external onlyOwner {

141:     function setExternalFeePercent(

155:     function setReferralFeeDestination(

162:     function setERC20Factory(address factory_) external onlyOwner {

166:     function getFees(

180:     function getPrice(uint256 supply, uint256 amount) public pure returns (uint256) {

189:     function getBuyPrice(address curvesTokenSubject, uint256 amount) public view returns (uint256) {

193:     function getSellPrice(address curvesTokenSubject, uint256 amount) public view returns (uint256) {

197:     function getBuyPriceAfterFee(address curvesTokenSubject, uint256 amount) public view returns (uint256) {

204:     function getSellPriceAfterFee(address curvesTokenSubject, uint256 amount) public view returns (uint256) {

211:     function buyCurvesToken(address curvesTokenSubject, uint256 amount) public payable {

218:     function _transferFees(

263:     function _buyCurvesToken(address curvesTokenSubject, uint256 amount) internal {

282:     function sellCurvesToken(address curvesTokenSubject, uint256 amount) public {

296:     function transferCurvesToken(address curvesTokenSubject, address to, uint256 amount) external {

302:     function transferAllCurvesTokens(address to) external {

313:     function _transfer(address curvesTokenSubject, address from, address to, uint256 amount) internal {

328:     function _addOwnedCurvesTokenSubject(address owner_, address curvesTokenSubject) internal {

338:     function _deployERC20(

364:     function buyCurvesTokenWithName(

377:     function buyCurvesTokenForPresale(

394:     function setWhitelist(bytes32 merkleRoot) external {

404:     function buyCurvesTokenWhitelisted(

422:     function verifyMerkle(address curvesTokenSubject, address caller, bytes32[] memory proof) public view {

428:     function setNameAndSymbol(

439:     function mint(address curvesTokenSubject) external onlyTokenSubject(curvesTokenSubject) {

456:     function _mint(

465:     function withdraw(address curvesTokenSubject, uint256 amount) public {

490:     function deposit(address curvesTokenSubject, uint256 amount) public {

504:     function sellExternalCurvesToken(address curvesTokenSubject, uint256 amount) public {

```

```solidity
File: contracts/CurvesERC20.sol

8:     constructor(string memory name_, string memory symbol_, address owner) ERC20(name_, symbol_) {

12:     function mint(address to, uint256 amount) public onlyOwner {

16:     function burn(address from, uint256 amount) public onlyOwner {

```

```solidity
File: contracts/CurvesERC20Factory.sol

7:     function deploy(string memory name, string memory symbol, address owner) public returns (address) {

```

```solidity
File: contracts/FeeSplitter.sol

33:     constructor() Security() {}

35:     function setCurves(Curves curves_) public {

39:     function balanceOf(address token, address account) public view returns (uint256) {

43:     function totalSupply(address token) public view returns (uint256) {

48:     function getUserTokens(address user) public view returns (address[] memory) {

52:     function getUserTokensAndClaimable(address user) public view returns (UserClaimData[] memory) {

63:     function updateFeeCredit(address token, address account) internal {

73:     function getClaimableFees(address token, address account) public view returns (uint256) {

80:     function claimFees(address token) external {

89:     function addFees(address token) public payable onlyManager {

96:     function onBalanceChange(address token, address account) public onlyManager {

103:     function batchClaiming(address[] calldata tokenList) external {

119:     receive() external payable {}

```

```solidity
File: contracts/Security.sol

18:     constructor() {

23:     function setManager(address manager_, bool value) public onlyOwner {

27:     function transferOwnership(address owner_) public onlyOwner {

```

</details>


<a name="NC-48"></a> 
### [NC-48] Missing NatSpec `@notice` from modifier declaration
Some modifier definitions have an incomplete NatSpec: add a `@notice` notation to improve the code documentation.

*There are <b>3</b> instances of this issue:*
```solidity
File: contracts/Curves.sol

103:     modifier onlyTokenSubject(address curvesTokenSubject) {

```

```solidity
File: contracts/Security.sol

8:     modifier onlyOwner() {

13:     modifier onlyManager() {

```


<a name="NC-49"></a> 
### [NC-49] Missing NatSpec `@param` from event declaration
Some event definitions have an incomplete NatSpec: add a `@param` notation to improve the code documentation.

*There are <b>5</b> instances of this issue:*
```solidity
File: contracts/Curves.sol

80:     event Trade(

91:     event Transfer(address indexed curvesTokenSubject, address indexed from, address indexed to, uint256 value);

92:     event WhitelistUpdated(address indexed presale, bytes32 indexed root);

93:     event TokenDeployed(address indexed curvesTokenSubject, address indexed erc20token, string name, string symbol);

```

```solidity
File: contracts/FeeSplitter.sol

31:     event FeesClaimed(address indexed token, address indexed user, uint256 amount);

```


<a name="NC-50"></a> 
### [NC-50] Missing NatSpec `@param` from function declaration
Some function definitions have an incomplete NatSpec: add a `@param` notation to improve the code documentation.

<details>
<summary>
There are <b>50</b> instances (click to show):
</summary>

```solidity
File: contracts/Curves.sol

/// @audit missing @param for `curvesERC20Factory_`
/// @audit missing @param for `feeRedistributor_`
108:     constructor(address curvesERC20Factory_, address feeRedistributor_) Security() {

/// @audit missing @param for `feeRedistributor_`
113:     function setFeeRedistributor(address feeRedistributor_) external onlyOwner {

/// @audit missing @param for `maxFeePercent_`
117:     function setMaxFeePercent(uint256 maxFeePercent_) external onlyManager {

/// @audit missing @param for `protocolFeePercent_`
/// @audit missing @param for `protocolFeeDestination_`
128:     function setProtocolFeePercent(uint256 protocolFeePercent_, address protocolFeeDestination_) external onlyOwner {

/// @audit missing @param for `subjectFeePercent_`
/// @audit missing @param for `referralFeePercent_`
/// @audit missing @param for `holdersFeePercent_`
141:     function setExternalFeePercent(
             uint256 subjectFeePercent_,
             uint256 referralFeePercent_,
             uint256 holdersFeePercent_
         ) external onlyManager {

/// @audit missing @param for `curvesTokenSubject`
/// @audit missing @param for `referralFeeDestination_`
155:     function setReferralFeeDestination(
             address curvesTokenSubject,
             address referralFeeDestination_
         ) public onlyTokenSubject(curvesTokenSubject) {

/// @audit missing @param for `factory_`
162:     function setERC20Factory(address factory_) external onlyOwner {

/// @audit missing @param for `price`
166:     function getFees(
             uint256 price
         )
             public
             view
             returns (uint256 protocolFee, uint256 subjectFee, uint256 referralFee, uint256 holdersFee, uint256 totalFee)
         {

/// @audit missing @param for `supply`
/// @audit missing @param for `amount`
180:     function getPrice(uint256 supply, uint256 amount) public pure returns (uint256) {

/// @audit missing @param for `curvesTokenSubject`
/// @audit missing @param for `amount`
189:     function getBuyPrice(address curvesTokenSubject, uint256 amount) public view returns (uint256) {

/// @audit missing @param for `curvesTokenSubject`
/// @audit missing @param for `amount`
193:     function getSellPrice(address curvesTokenSubject, uint256 amount) public view returns (uint256) {

/// @audit missing @param for `curvesTokenSubject`
/// @audit missing @param for `amount`
197:     function getBuyPriceAfterFee(address curvesTokenSubject, uint256 amount) public view returns (uint256) {

/// @audit missing @param for `curvesTokenSubject`
/// @audit missing @param for `amount`
204:     function getSellPriceAfterFee(address curvesTokenSubject, uint256 amount) public view returns (uint256) {

/// @audit missing @param for `curvesTokenSubject`
/// @audit missing @param for `amount`
211:     function buyCurvesToken(address curvesTokenSubject, uint256 amount) public payable {

/// @audit missing @param for `curvesTokenSubject`
/// @audit missing @param for `isBuy`
/// @audit missing @param for `price`
/// @audit missing @param for `amount`
/// @audit missing @param for `supply`
218:     function _transferFees(
             address curvesTokenSubject,
             bool isBuy,
             uint256 price,
             uint256 amount,
             uint256 supply
         ) internal {

/// @audit missing @param for `curvesTokenSubject`
/// @audit missing @param for `amount`
263:     function _buyCurvesToken(address curvesTokenSubject, uint256 amount) internal {

/// @audit missing @param for `curvesTokenSubject`
/// @audit missing @param for `amount`
282:     function sellCurvesToken(address curvesTokenSubject, uint256 amount) public {

/// @audit missing @param for `curvesTokenSubject`
/// @audit missing @param for `to`
/// @audit missing @param for `amount`
296:     function transferCurvesToken(address curvesTokenSubject, address to, uint256 amount) external {

/// @audit missing @param for `to`
302:     function transferAllCurvesTokens(address to) external {

/// @audit missing @param for `curvesTokenSubject`
/// @audit missing @param for `from`
/// @audit missing @param for `to`
/// @audit missing @param for `amount`
313:     function _transfer(address curvesTokenSubject, address from, address to, uint256 amount) internal {

/// @audit missing @param for `owner_`
/// @audit missing @param for `curvesTokenSubject`
328:     function _addOwnedCurvesTokenSubject(address owner_, address curvesTokenSubject) internal {

/// @audit missing @param for `curvesTokenSubject`
/// @audit missing @param for `name`
/// @audit missing @param for `symbol`
338:     function _deployERC20(
             address curvesTokenSubject,
             string memory name,
             string memory symbol
         ) internal returns (address) {

/// @audit missing @param for `curvesTokenSubject`
/// @audit missing @param for `amount`
/// @audit missing @param for `name`
/// @audit missing @param for `symbol`
364:     function buyCurvesTokenWithName(
             address curvesTokenSubject,
             uint256 amount,
             string memory name,
             string memory symbol
         ) public payable {

/// @audit missing @param for `curvesTokenSubject`
/// @audit missing @param for `amount`
/// @audit missing @param for `startTime`
/// @audit missing @param for `merkleRoot`
/// @audit missing @param for `maxBuy`
377:     function buyCurvesTokenForPresale(
             address curvesTokenSubject,
             uint256 amount,
             uint256 startTime,
             bytes32 merkleRoot,
             uint256 maxBuy
         ) public payable onlyTokenSubject(curvesTokenSubject) {

/// @audit missing @param for `merkleRoot`
394:     function setWhitelist(bytes32 merkleRoot) external {

/// @audit missing @param for `curvesTokenSubject`
/// @audit missing @param for `amount`
/// @audit missing @param for `proof`
404:     function buyCurvesTokenWhitelisted(
             address curvesTokenSubject,
             uint256 amount,
             bytes32[] memory proof
         ) public payable {

/// @audit missing @param for `curvesTokenSubject`
/// @audit missing @param for `caller`
/// @audit missing @param for `proof`
422:     function verifyMerkle(address curvesTokenSubject, address caller, bytes32[] memory proof) public view {

/// @audit missing @param for `curvesTokenSubject`
/// @audit missing @param for `name`
/// @audit missing @param for `symbol`
428:     function setNameAndSymbol(
             address curvesTokenSubject,
             string memory name,
             string memory symbol
         ) external onlyTokenSubject(curvesTokenSubject) {

/// @audit missing @param for `curvesTokenSubject`
439:     function mint(address curvesTokenSubject) external onlyTokenSubject(curvesTokenSubject) {

/// @audit missing @param for `curvesTokenSubject`
/// @audit missing @param for `name`
/// @audit missing @param for `symbol`
456:     function _mint(
             address curvesTokenSubject,
             string memory name,
             string memory symbol
         ) internal onlyTokenSubject(curvesTokenSubject) {

/// @audit missing @param for `curvesTokenSubject`
/// @audit missing @param for `amount`
465:     function withdraw(address curvesTokenSubject, uint256 amount) public {

/// @audit missing @param for `curvesTokenSubject`
/// @audit missing @param for `amount`
490:     function deposit(address curvesTokenSubject, uint256 amount) public {

/// @audit missing @param for `curvesTokenSubject`
/// @audit missing @param for `amount`
504:     function sellExternalCurvesToken(address curvesTokenSubject, uint256 amount) public {

```

```solidity
File: contracts/CurvesERC20.sol

/// @audit missing @param for `name_`
/// @audit missing @param for `symbol_`
/// @audit missing @param for `owner`
8:     constructor(string memory name_, string memory symbol_, address owner) ERC20(name_, symbol_) {

/// @audit missing @param for `to`
/// @audit missing @param for `amount`
12:     function mint(address to, uint256 amount) public onlyOwner {

/// @audit missing @param for `from`
/// @audit missing @param for `amount`
16:     function burn(address from, uint256 amount) public onlyOwner {

```

```solidity
File: contracts/CurvesERC20Factory.sol

/// @audit missing @param for `name`
/// @audit missing @param for `symbol`
/// @audit missing @param for `owner`
7:     function deploy(string memory name, string memory symbol, address owner) public returns (address) {

```

```solidity
File: contracts/FeeSplitter.sol

/// @audit missing @param for `curves_`
35:     function setCurves(Curves curves_) public {

/// @audit missing @param for `token`
/// @audit missing @param for `account`
39:     function balanceOf(address token, address account) public view returns (uint256) {

/// @audit missing @param for `token`
43:     function totalSupply(address token) public view returns (uint256) {

/// @audit missing @param for `user`
48:     function getUserTokens(address user) public view returns (address[] memory) {

/// @audit missing @param for `user`
52:     function getUserTokensAndClaimable(address user) public view returns (UserClaimData[] memory) {

/// @audit missing @param for `token`
/// @audit missing @param for `account`
63:     function updateFeeCredit(address token, address account) internal {

/// @audit missing @param for `token`
/// @audit missing @param for `account`
73:     function getClaimableFees(address token, address account) public view returns (uint256) {

/// @audit missing @param for `token`
80:     function claimFees(address token) external {

/// @audit missing @param for `token`
89:     function addFees(address token) public payable onlyManager {

/// @audit missing @param for `token`
/// @audit missing @param for `account`
96:     function onBalanceChange(address token, address account) public onlyManager {

/// @audit missing @param for `tokenList`
103:     function batchClaiming(address[] calldata tokenList) external {

```

```solidity
File: contracts/Security.sol

/// @audit missing @param for `manager_`
/// @audit missing @param for `value`
23:     function setManager(address manager_, bool value) public onlyOwner {

/// @audit missing @param for `owner_`
27:     function transferOwnership(address owner_) public onlyOwner {

```

</details>


<a name="NC-51"></a> 
### [NC-51] Missing NatSpec `@param` from modifier declaration
Some modifier definitions have an incomplete NatSpec: add a `@param` notation to improve the code documentation.

*There is one instance of this issue:*
```solidity
File: contracts/Curves.sol

103:     modifier onlyTokenSubject(address curvesTokenSubject) {

```


<a name="NC-52"></a> 
### [NC-52] Missing NatSpec `@return` from function declaration
Some function definitions have an incomplete NatSpec: add a `@return` notation to improve the code documentation.

<details>
<summary>
There are <b>13</b> instances (click to show):
</summary>

```solidity
File: contracts/Curves.sol

166:     function getFees(
             uint256 price
         )
             public
             view
             returns (uint256 protocolFee, uint256 subjectFee, uint256 referralFee, uint256 holdersFee, uint256 totalFee)
         {

180:     function getPrice(uint256 supply, uint256 amount) public pure returns (uint256) {

189:     function getBuyPrice(address curvesTokenSubject, uint256 amount) public view returns (uint256) {

193:     function getSellPrice(address curvesTokenSubject, uint256 amount) public view returns (uint256) {

197:     function getBuyPriceAfterFee(address curvesTokenSubject, uint256 amount) public view returns (uint256) {

204:     function getSellPriceAfterFee(address curvesTokenSubject, uint256 amount) public view returns (uint256) {

338:     function _deployERC20(
             address curvesTokenSubject,
             string memory name,
             string memory symbol
         ) internal returns (address) {

```

```solidity
File: contracts/CurvesERC20Factory.sol

7:     function deploy(string memory name, string memory symbol, address owner) public returns (address) {

```

```solidity
File: contracts/FeeSplitter.sol

39:     function balanceOf(address token, address account) public view returns (uint256) {

43:     function totalSupply(address token) public view returns (uint256) {

48:     function getUserTokens(address user) public view returns (address[] memory) {

52:     function getUserTokensAndClaimable(address user) public view returns (UserClaimData[] memory) {

73:     function getClaimableFees(address token, address account) public view returns (uint256) {

```

</details>


<a name="NC-53"></a> 
### [NC-53] Missing NatSpec `@title` from contract declaration
Some contract definitions have an incomplete NatSpec: add a `@title` notation to improve the code documentation.

*There are <b>6</b> instances of this issue:*
```solidity
File: contracts/Curves.sol

13: interface CurvesErrors {

41: contract Curves is CurvesErrors, Security {

```

```solidity
File: contracts/CurvesERC20.sol

7: contract CurvesERC20 is ERC20, Ownable {

```

```solidity
File: contracts/CurvesERC20Factory.sol

6: contract CurvesERC20Factory {

```

```solidity
File: contracts/FeeSplitter.sol

9: contract FeeSplitter is Security {

```

```solidity
File: contracts/Security.sol

4: contract Security {

```


<a name="NC-54"></a> 
### [NC-54] There is no need to initialize variables with 0
Since the variables are automatically set to 0 when created, it is redundant to initialize it with 0 again.

*There are <b>6</b> instances of this issue:*
```solidity
File: contracts/Curves.sol

47:     uint256 private _curvesTokenCounter = 0;

305:         for (uint256 i = 0; i < subjects.length; i++) {

330:         for (uint256 i = 0; i < subjects.length; i++) {

```

```solidity
File: contracts/FeeSplitter.sol

55:         for (uint256 i = 0; i < tokens.length; i++) {

104:         uint256 totalClaimable = 0;

105:         for (uint256 i = 0; i < tokenList.length; i++) {

```


<a name="NC-55"></a> 
### [NC-55] Potential Re-org Attack Vector
The contract appears to deploy new contracts using the `new` keyword. In a re-org attack scenario, such deployments can be exploited by a malicious actor who might rewrite the blockchain's history and deploy the contract at an expected address.

Consider deploying the contract via `CREATE2` opcode with a specific salt that includes `msg.sender` and the existing contract address. This will ensure a predictable contract address, reducing the chances of such an attack.

*There is one instance of this issue:*
```solidity
File: contracts/CurvesERC20Factory.sol

8:         CurvesERC20 tokenContract = new CurvesERC20(name, symbol, owner);

```


<a name="NC-56"></a> 
### [NC-56] Put all system-wide constants in one file
Putting all the system-wide constants in a single file improves code readability, makes it easier to understand the basic configuration and limitations of the system, and makes maintenance easier.

*There are <b>3</b> instances of this issue:*
```solidity
File: contracts/Curves.sol

44:     string public constant DEFAULT_NAME = "Curves";

45:     string public constant DEFAULT_SYMBOL = "CURVES";

```

```solidity
File: contracts/FeeSplitter.sol

11:     uint256 constant PRECISION = 1e18;

```


<a name="NC-57"></a> 
### [NC-57] The remaining ETH may be locked in the contract after call
After calling an external contract and forwards some ETH value, the contract balance should be checked. If there is excess eth left over due to a failed call, or more eth being delivered than needed, or any other reason, this eth must be refunded to the user or handled appropriately, otherwise the eth may be frozen in the contract forever.

*There is one instance of this issue:*
```solidity
File: contracts/Curves.sol

232:                 (bool success1, ) = firstDestination.call{value: isBuy ? buyValue : sellValue}("");

```


<a name="NC-58"></a> 
### [NC-58] Setters should prevent re-setting the same value
Not only is wasteful in terms of gas, but this is especially problematic when an event is emitted and the old and new values set are the same, as listeners might not expect this kind of scenario.

*There are <b>4</b> instances of this issue:*
```solidity
File: contracts/Curves.sol

159:         referralFeeDestination[curvesTokenSubject] = referralFeeDestination_;

163:         curvesERC20Factory = factory_;

```

```solidity
File: contracts/FeeSplitter.sol

36:         curves = curves_;

```

```solidity
File: contracts/Security.sol

24:         managers[manager_] = value;

```


<a name="NC-59"></a> 
### [NC-59] State variables should include comments
Consider adding some comments on critical state variables to explain what they are supposed to do: this will help for future code reviews.

*There are <b>6</b> instances of this issue:*
```solidity
File: contracts/Curves.sol

42:     address public curvesERC20Factory;

44:     string public constant DEFAULT_NAME = "Curves";

45:     string public constant DEFAULT_SYMBOL = "CURVES";

47:     uint256 private _curvesTokenCounter = 0;

```

```solidity
File: contracts/FeeSplitter.sol

11:     uint256 constant PRECISION = 1e18;

```

```solidity
File: contracts/Security.sol

5:     address public owner;

```


<a name="NC-60"></a> 
### [NC-60] Unnecessary cast
The variable is being cast to its own type.

*There is one instance of this issue:*
```solidity
File: contracts/Curves.sol

/// @audit no need to cast `tokenContract` into address
361:         return address(tokenContract);

```


<a name="NC-61"></a> 
### [NC-61] Unsafe solidity low-level call can cause gas grief attack
Using the low-level calls of a solidity address can leave the contract open to gas grief attacks. These attacks occur when the called contract returns a large amount of data. So when calling an external contract, it is necessary to check the length of the return data before reading/copying it (using `returndatasize()`).

*There is one instance of this issue:*
```solidity
File: contracts/Curves.sol

232:                 (bool success1, ) = firstDestination.call{value: isBuy ? buyValue : sellValue}("");

```


<a name="NC-62"></a> 
### [NC-62] Consider using `delete` rather than assigning zero/false to clear values
The `delete` keyword more closely matches the semantics of what is being done, and draws more attention to the changing of state, which may lead to a more thorough audit of its associated logic.

*There are <b>2</b> instances of this issue:*
```solidity
File: contracts/FeeSplitter.sol

84:         tokensData[token].unclaimedFees[msg.sender] = 0;

110:                 tokensData[token].unclaimedFees[msg.sender] = 0;

```


<a name="NC-63"></a> 
### [NC-63] Solidity compiler version is not fixed
To prevent the actual contracts deployed from behaving differently depending on the compiler version, it is recommended to use a fixed solidity version.

*There are <b>5</b> instances of this issue:*
```solidity
File: contracts/Curves.sol

2: pragma solidity ^0.8.7;

```

```solidity
File: contracts/CurvesERC20.sol

2: pragma solidity ^0.8.7;

```

```solidity
File: contracts/CurvesERC20Factory.sol

2: pragma solidity ^0.8.7;

```

```solidity
File: contracts/FeeSplitter.sol

2: pragma solidity ^0.8.7;

```

```solidity
File: contracts/Security.sol

2: pragma solidity ^0.8.7;

```


<a name="NC-64"></a> 
### [NC-64] Expressions for constant values should use `immutable` rather than `constant`
While it doesn't save any gas because the compiler knows that developers often make this mistake, it's still best to use the right tool for the task at hand. There is a difference between `constant` variables and `immutable` variables, and they should each be used in their appropriate contexts. `constants` should be used for literal values written into the code, and `immutable` variables should be used for expressions, or values calculated in, or passed into the constructor.

*There are <b>3</b> instances of this issue:*
```solidity
File: contracts/Curves.sol

44:     string public constant DEFAULT_NAME = "Curves";

45:     string public constant DEFAULT_SYMBOL = "CURVES";

```

```solidity
File: contracts/FeeSplitter.sol

11:     uint256 constant PRECISION = 1e18;

```


<a name="NC-65"></a> 
### [NC-65] Use the latest solidity version for deployment (`0.8.23`)
Upgrading to a newer Solidity release can optimize gas usage, take advantage of new features and improve overall contract efficiency. Where possible, based on compatibility requirements, it is recommended to use newer/latest solidity version to take advantage of the latest optimizations and features.

*There are <b>5</b> instances of this issue:*
```solidity
File: contracts/Curves.sol

2: pragma solidity ^0.8.7;

```

```solidity
File: contracts/CurvesERC20.sol

2: pragma solidity ^0.8.7;

```

```solidity
File: contracts/CurvesERC20Factory.sol

2: pragma solidity ^0.8.7;

```

```solidity
File: contracts/FeeSplitter.sol

2: pragma solidity ^0.8.7;

```

```solidity
File: contracts/Security.sol

2: pragma solidity ^0.8.7;

```


<a name="NC-66"></a> 
### [NC-66] Consider using modifiers for address control
Modifiers in Solidity can improve code readability and modularity by encapsulating repetitive checks, such as address validity checks, into a reusable construct. For example, an `onlyOwner` modifier can be used to replace repetitive `require(msg.sender == owner)` checks across several functions, reducing code redundancy and enhancing maintainability. To implement, define a modifier with the check, then apply the modifier to relevant functions.

*There are <b>2</b> instances of this issue:*
```solidity
File: contracts/Curves.sol

104:         if (curvesTokenSubject != msg.sender) revert UnauthorizedCurvesTokenSubject();

265:         if (!(supply > 0 || curvesTokenSubject == msg.sender)) revert UnauthorizedCurvesTokenSubject();

```


<a name="NC-67"></a> 
### [NC-67] Returning a struct instead of a bunch of variables is better
If a function returns [too many variables](https://docs.soliditylang.org/en/v0.8.21/contracts.html#returning-multiple-values), replacing them with a struct can improve code readability, maintainability and reusability.

*There is one instance of this issue:*
```solidity
File: contracts/Curves.sol

/// @audit 5 return variables
166:     function getFees(
             uint256 price
         )
             public
             view
             returns (uint256 protocolFee, uint256 subjectFee, uint256 referralFee, uint256 holdersFee, uint256 totalFee)
         {

```


<a name="NC-68"></a> 
### [NC-68] Visibility of state variables is not explicitly defined
To avoid misunderstandings and unexpected state accesses, it is recommended to explicitly define the visibility of each state variable.

*There is one instance of this issue:*
```solidity
File: contracts/FeeSplitter.sol

11:     uint256 constant PRECISION = 1e18;

```


<a name="NC-69"></a> 
### [NC-69] Whitespace in Expressions
See the [Whitespace in Expressions](https://docs.soliditylang.org/en/latest/style-guide.html#whitespace-in-expressions) section of the Solidity Style Guide.

*There are <b>4</b> instances of this issue:*
```solidity
File: contracts/Curves.sol

225:         (uint256 protocolFee, uint256 subjectFee, uint256 referralFee, uint256 holderFee, ) = getFees(price);

232:                 (bool success1, ) = firstDestination.call{value: isBuy ? buyValue : sellValue}("");

236:                 (bool success2, ) = curvesTokenSubject.call{value: subjectFee}("");

240:                 (bool success3, ) = referralDefined

```


<a name="NC-70"></a> 
### [NC-70] Empty body - Consider commenting why

*There are <b>2</b> instances of this issue:*
```solidity
File: contracts/FeeSplitter.sol

33:     constructor() Security() {}

119:     receive() external payable {}

```


<a name="NC-71"></a> 
### [NC-71] Names of `private`/`internal` functions should be prefixed with an underscore
It is recommended by the [Solidity Style Guide](https://docs.soliditylang.org/en/v0.8.20/style-guide.html#underscore-prefix-for-non-external-functions-and-variables)

*There is one instance of this issue:*
```solidity
File: contracts/FeeSplitter.sol

63:     function updateFeeCredit(address token, address account) internal {

```


<a name="NC-72"></a> 
### [NC-72] Names of `private`/`internal` state variables should be prefixed with an underscore
It is recommended by the [Solidity Style Guide](https://docs.soliditylang.org/en/v0.8.20/style-guide.html#underscore-prefix-for-non-external-functions-and-variables)

*There are <b>4</b> instances of this issue:*
```solidity
File: contracts/Curves.sol

101:     mapping(address => address[]) private ownedCurvesTokenSubjects;

```

```solidity
File: contracts/FeeSplitter.sol

11:     uint256 constant PRECISION = 1e18;

28:     mapping(address => TokenData) internal tokensData;

29:     mapping(address => address[]) internal userTokens;

```


<a name="NC-73"></a> 
### [NC-73] Internal function calls within for loops
Making function calls or external calls within loops in Solidity can lead to inefficient gas usage, potential bottlenecks, and increased vulnerability to attacks. Each function call or external call consumes gas, and when executed within a loop, the gas cost multiplies, potentially causing the transaction to run out of gas or exceed block gas limits. This can result in transaction failure or unpredictable behavior.

*There are <b>2</b> instances of this issue:*
```solidity
File: contracts/Curves.sol

/// @audit `_transfer`
330:         for (uint256 i = 0; i < subjects.length; i++) {

```

```solidity
File: contracts/FeeSplitter.sol

/// @audit `getClaimableFees`
/// @audit `updateFeeCredit`
/// @audit `getClaimableFees`
105:         for (uint256 i = 0; i < tokenList.length; i++) {

```


<a name="NC-74"></a> 
### [NC-74] Event is missing `indexed` fields
Index event fields make the field more quickly accessible to off-chain tools that parse events. However, note that each index field costs extra gas during emission, so it's not necessarily best to index the maximum allowed per event (three fields). Each event should use three indexed fields if there are three or more fields, and gas usage is not particularly of concern for the events in question. If there are fewer than three fields, all of the fields should be indexed.

*There are <b>3</b> instances of this issue:*
```solidity
File: contracts/Curves.sol

80:     event Trade(

93:     event TokenDeployed(address indexed curvesTokenSubject, address indexed erc20token, string name, string symbol);

```

```solidity
File: contracts/FeeSplitter.sol

31:     event FeesClaimed(address indexed token, address indexed user, uint256 amount);

```


<a name="NC-75"></a> 
### [NC-75] Functions not used internally could be marked `external`

<details>
<summary>
There are <b>18</b> instances (click to show):
</summary>

```solidity
File: contracts/Curves.sol

155:     function setReferralFeeDestination(

197:     function getBuyPriceAfterFee(address curvesTokenSubject, uint256 amount) public view returns (uint256) {

204:     function getSellPriceAfterFee(address curvesTokenSubject, uint256 amount) public view returns (uint256) {

211:     function buyCurvesToken(address curvesTokenSubject, uint256 amount) public payable {

364:     function buyCurvesTokenWithName(

377:     function buyCurvesTokenForPresale(

404:     function buyCurvesTokenWhitelisted(

465:     function withdraw(address curvesTokenSubject, uint256 amount) public {

504:     function sellExternalCurvesToken(address curvesTokenSubject, uint256 amount) public {

```

```solidity
File: contracts/CurvesERC20.sol

12:     function mint(address to, uint256 amount) public onlyOwner {

16:     function burn(address from, uint256 amount) public onlyOwner {

```

```solidity
File: contracts/CurvesERC20Factory.sol

7:     function deploy(string memory name, string memory symbol, address owner) public returns (address) {

```

```solidity
File: contracts/FeeSplitter.sol

35:     function setCurves(Curves curves_) public {

52:     function getUserTokensAndClaimable(address user) public view returns (UserClaimData[] memory) {

89:     function addFees(address token) public payable onlyManager {

96:     function onBalanceChange(address token, address account) public onlyManager {

```

```solidity
File: contracts/Security.sol

23:     function setManager(address manager_, bool value) public onlyOwner {

27:     function transferOwnership(address owner_) public onlyOwner {

```

</details>



## Gas Optimizations

<a name="GAS-1"></a> 
### [GAS-1] Assigning to structs can be more efficient
By changing the pattern of assigning value to the structure, gas savings of ~130 per instance are achieved. In addition, this use will provide significant savings in distribution costs. Instead of:
```solidity
MyStruct memory myStruct = MyStruct(_a, _b, _c);
```
write:
```solidity
MyStruct memory myStruct;
myStruct.a = _a;
myStruct.b = _b;
myStruct.c = _c;
```

*There is one instance of this issue:*
```solidity
File: contracts/FeeSplitter.sol

58:             result[i] = UserClaimData(claimable, token);

```


<a name="GAS-2"></a> 
### [GAS-2] Optimize gas by using do-while loops
Using `do-while` loops instead of `for` loops can be more gas-efficient. Even if you add an `if` condition to account for the case where the loop doesn't execute at all, a `do-while` loop can still be cheaper in terms of gas.

*There are <b>4</b> instances of this issue:*
```solidity
File: contracts/Curves.sol

305:         for (uint256 i = 0; i < subjects.length; i++) {

330:         for (uint256 i = 0; i < subjects.length; i++) {

```

```solidity
File: contracts/FeeSplitter.sol

55:         for (uint256 i = 0; i < tokens.length; i++) {

105:         for (uint256 i = 0; i < tokenList.length; i++) {

```


<a name="GAS-3"></a> 
### [GAS-3] Multiple `address`/ID mappings can be combined into a single `mapping` of an `address`/ID to a `struct`, where appropriate
Saves a storage slot for the mapping. Depending on the circumstances and sizes of types, can avoid a Gsset (20000 gas) per mapping combined. Reads and subsequent writes can also be cheaper when a function requires both values and they both fit in the same storage slot. Finally, if both fields are accessed in the same function, can save ~42 gas per access due to not having to [recalculate the key's keccak256 hash](https://gist.github.com/IllIllI000/ec23a57daa30a8f8ca8b9681c8ccefb0) (Gkeccak256 - 30 gas) and that calculation's associated stack operations.

*There are <b>2</b> instances of this issue:*
```solidity
File: contracts/Curves.sol

66:     mapping(address => mapping(address => uint256)) public presalesBuys;

96:     mapping(address => mapping(address => uint256)) public curvesTokenBalance;

```


<a name="GAS-4"></a> 
### [GAS-4] Consider activating via-ir for deploying
By using `--via-ir` or `{"viaIR": true}`, the compiler is able to use more advanced [multi-function optimizations](https://docs.soliditylang.org/en/v0.8.17/ir-breaking-changes.html#solidity-ir-based-codegen-changes), for extra gas savings.

*There is one instance of this issue:*
```solidity

Global finding

```


<a name="GAS-5"></a> 
### [GAS-5] Divisions can be `unchecked` to save gas
The expression `type(int).min/(-1)` is the only case where division causes an overflow. Therefore, uncheck can be used to [save gas](https://gist.github.com/DadeKuma/3bc597338ae774b8b3bd43280d55271f) in scenarios where it is certain that such an overflow will not occur.

<details>
<summary>
There are <b>12</b> instances (click to show):
</summary>

```solidity
File: contracts/Curves.sol

173:         protocolFee = (price * feesEconomics.protocolFeePercent) / 1 ether;

174:         subjectFee = (price * feesEconomics.subjectFeePercent) / 1 ether;

175:         referralFee = (price * feesEconomics.referralFeePercent) / 1 ether;

176:         holdersFee = (price * feesEconomics.holdersFeePercent) / 1 ether;

181:         uint256 sum1 = supply == 0 ? 0 : ((supply - 1) * (supply) * (2 * (supply - 1) + 1)) / 6;

184:             : ((supply - 1 + amount) * (supply + amount) * (2 * (supply - 1 + amount) + 1)) / 6;

186:         return (summation * 1 ether) / 16000;

494:         uint256 tokenAmount = amount / 1 ether;

508:         sellCurvesToken(curvesTokenSubject, amount / 1 ether);

```

```solidity
File: contracts/FeeSplitter.sol

68:             data.unclaimedFees[account] += owed / PRECISION;

77:         return (owed / PRECISION) + data.unclaimedFees[account];

93:         data.cumulativeFeePerToken += (msg.value * PRECISION) / totalSupply_;

```

</details>


<a name="GAS-6"></a> 
### [GAS-6] Operator `+=` costs more gas than `<x> = <x> + <y>` for state variables

*There is one instance of this issue:*
```solidity
File: contracts/Curves.sol

/// @audit `_curvesTokenCounter +=`
345:             _curvesTokenCounter += 1;

```


<a name="GAS-7"></a> 
### [GAS-7] Events should be emitted outside of loops
Emitting an event has an overhead of 375 gas, which will be incurred on every iteration of the loop. It is cheaper to emit only once after the loop has finished.

*There is one instance of this issue:*
```solidity
File: contracts/FeeSplitter.sol

112:                 emit FeesClaimed(token, msg.sender, claimable);

```


<a name="GAS-8"></a> 
### [GAS-8] Increments can be `unchecked` to save gas
Using `unchecked` increments can save gas by bypassing the built-in overflow checks. This can save 30-40 gas per iteration. So it is recommended to use unchecked increments when overflow is not possible.

*There are <b>4</b> instances of this issue:*
```solidity
File: contracts/Curves.sol

305:         for (uint256 i = 0; i < subjects.length; i++) {

330:         for (uint256 i = 0; i < subjects.length; i++) {

```

```solidity
File: contracts/FeeSplitter.sol

55:         for (uint256 i = 0; i < tokens.length; i++) {

105:         for (uint256 i = 0; i < tokenList.length; i++) {

```


<a name="GAS-9"></a> 
### [GAS-9] Low level `call` can be optimized with assembly
When using low-level calls, the `returnData` is copied to memory even if the variable is not utilized. The proper way to handle this is through a low level assembly call.

*There are <b>3</b> instances of this issue:*
```solidity
File: contracts/Curves.sol

232:                 (bool success1, ) = firstDestination.call{value: isBuy ? buyValue : sellValue}("");

236:                 (bool success2, ) = curvesTokenSubject.call{value: subjectFee}("");

241:                     ? referralFeeDestination[curvesTokenSubject].call{value: referralFee}("")

```


<a name="GAS-10"></a> 
### [GAS-10] Multiple accesses of the same mapping/array key/index should be cached
The instances below point to the second+ access of a value inside a mapping/array, within a function. Caching a mapping's value in a local `storage` or `calldata` variable when the value is accessed [multiple times](https://gist.github.com/IllIllI000/ec23a57daa30a8f8ca8b9681c8ccefb0), saves ~42 gas per access due to not having to recalculate the key's keccak256 hash (Gkeccak256 - 30 gas) and that calculation's associated stack operations. Caching an array's struct avoids recalculating the array offsets into memory/calldata

<details>
<summary>
There are <b>30</b> instances (click to show):
</summary>

```solidity
File: contracts/Curves.sol

/// @audit `referralFeeDestination[curvesTokenSubject]` is also accessed on line 227
241:                     ? referralFeeDestination[curvesTokenSubject].call{value: referralFee}("")

/// @audit `curvesTokenSupply[curvesTokenSubject]` is also accessed on line 264
273:         curvesTokenSupply[curvesTokenSubject] = supply + amount;

/// @audit `curvesTokenBalance[curvesTokenSubject]` is also accessed on line 272
277:         if (curvesTokenBalance[curvesTokenSubject][msg.sender] - amount == 0) {

/// @audit `curvesTokenBalance[curvesTokenSubject]` is also accessed on line 285
289:         curvesTokenBalance[curvesTokenSubject][msg.sender] -= amount;

/// @audit `curvesTokenSupply[curvesTokenSubject]` is also accessed on line 283
290:         curvesTokenSupply[curvesTokenSubject] = supply - amount;

/// @audit `curvesTokenBalance[curvesTokenSubject]` is also accessed on line 314
321:         curvesTokenBalance[curvesTokenSubject][from] = curvesTokenBalance[curvesTokenSubject][from] - amount;

/// @audit `curvesTokenBalance[curvesTokenSubject]` is also accessed on line 314
322:         curvesTokenBalance[curvesTokenSubject][to] = curvesTokenBalance[curvesTokenSubject][to] + amount;

/// @audit `externalCurvesTokens[curvesTokenSubject]` is also accessed on line 354
355:         externalCurvesTokens[curvesTokenSubject].name = name;

/// @audit `externalCurvesTokens[curvesTokenSubject]` is also accessed on line 354
356:         externalCurvesTokens[curvesTokenSubject].symbol = symbol;

/// @audit `symbolToSubject[symbol]` is also accessed on line 350
358:         symbolToSubject[symbol] = curvesTokenSubject;

/// @audit `presalesMeta[curvesTokenSubject]` is also accessed on line 387
388:         presalesMeta[curvesTokenSubject].merkleRoot = merkleRoot;

/// @audit `presalesMeta[curvesTokenSubject]` is also accessed on line 387
389:         presalesMeta[curvesTokenSubject].maxBuy = (maxBuy == 0 ? type(uint256).max : maxBuy);

/// @audit `presalesMeta[msg.sender]` is also accessed on line 398
399:             presalesMeta[msg.sender].merkleRoot = merkleRoot;

/// @audit `presalesMeta[curvesTokenSubject]` is also accessed on line 410
411:             presalesMeta[curvesTokenSubject].startTime <= block.timestamp

/// @audit `presalesBuys[curvesTokenSubject]` is also accessed on line 414
415:         uint256 tokenBought = presalesBuys[curvesTokenSubject][msg.sender];

/// @audit `presalesMeta[curvesTokenSubject]` is also accessed on line 410
416:         if (tokenBought > presalesMeta[curvesTokenSubject].maxBuy) revert ExceededMaxBuyAmount();

/// @audit `externalCurvesTokens[curvesTokenSubject]` is also accessed on line 433
435:         externalCurvesTokens[curvesTokenSubject].name = name;

/// @audit `externalCurvesTokens[curvesTokenSubject]` is also accessed on line 433
436:         externalCurvesTokens[curvesTokenSubject].symbol = symbol;

/// @audit `externalCurvesTokens[curvesTokenSubject]` is also accessed on line 441
443:             keccak256(abi.encodePacked(externalCurvesTokens[curvesTokenSubject].symbol)) ==

/// @audit `externalCurvesTokens[curvesTokenSubject]` is also accessed on line 441
446:             externalCurvesTokens[curvesTokenSubject].name = DEFAULT_NAME;

/// @audit `externalCurvesTokens[curvesTokenSubject]` is also accessed on line 441
447:             externalCurvesTokens[curvesTokenSubject].symbol = DEFAULT_SYMBOL;

/// @audit `externalCurvesTokens[curvesTokenSubject]` is also accessed on line 441
451:             externalCurvesTokens[curvesTokenSubject].name,

/// @audit `externalCurvesTokens[curvesTokenSubject]` is also accessed on line 441
452:             externalCurvesTokens[curvesTokenSubject].symbol

/// @audit `externalCurvesTokens[curvesTokenSubject]` is also accessed on line 468
471:                 keccak256(abi.encodePacked(externalCurvesTokens[curvesTokenSubject].name)) ==

/// @audit `externalCurvesTokens[curvesTokenSubject]` is also accessed on line 468
473:                 keccak256(abi.encodePacked(externalCurvesTokens[curvesTokenSubject].symbol)) ==

/// @audit `externalCurvesTokens[curvesTokenSubject]` is also accessed on line 468
476:                 externalCurvesTokens[curvesTokenSubject].name = DEFAULT_NAME;

/// @audit `externalCurvesTokens[curvesTokenSubject]` is also accessed on line 468
477:                 externalCurvesTokens[curvesTokenSubject].symbol = DEFAULT_SYMBOL;

/// @audit `externalCurvesTokens[curvesTokenSubject]` is also accessed on line 468
481:                 externalCurvesTokens[curvesTokenSubject].name,

/// @audit `externalCurvesTokens[curvesTokenSubject]` is also accessed on line 468
482:                 externalCurvesTokens[curvesTokenSubject].symbol

/// @audit `externalCurvesTokens[curvesTokenSubject]` is also accessed on line 468
484:             externalToken = externalCurvesTokens[curvesTokenSubject].token;

```

</details>


<a name="GAS-11"></a> 
### [GAS-11] Newer versions of solidity are more gas efficient
The solidity language continues to pursue more efficient gas optimization schemes. Adopting a newer version of solidity can be more gas efficient.

*There are <b>5</b> instances of this issue:*
```solidity
File: contracts/Curves.sol

2: pragma solidity ^0.8.7;

```

```solidity
File: contracts/CurvesERC20.sol

2: pragma solidity ^0.8.7;

```

```solidity
File: contracts/CurvesERC20Factory.sol

2: pragma solidity ^0.8.7;

```

```solidity
File: contracts/FeeSplitter.sol

2: pragma solidity ^0.8.7;

```

```solidity
File: contracts/Security.sol

2: pragma solidity ^0.8.7;

```


<a name="GAS-12"></a> 
### [GAS-12] Operator `>=`/`<=` costs less gas than operator `>`/`<`
The compiler uses opcodes `GT` and `ISZERO` for code that uses `>`, but only requires `LT` for `>=`. A similar behavior applies for `>`, which uses opcodes `LT` and `ISZERO`, but only requires `GT` for `<=`. It can save 3 gas for each. It should be converted to the `<=`/`>=` equivalent when comparing against integer literals.

<details>
<summary>
There are <b>16</b> instances (click to show):
</summary>

```solidity
File: contracts/Curves.sol

246:             if (feesEconomics.holdersFeePercent > 0 && address(feeRedistributor) != address(0)) {

265:         if (!(supply > 0 || curvesTokenSubject == msg.sender)) revert UnauthorizedCurvesTokenSubject();

270:         if (msg.value < price + totalFee) revert InsufficientPayment();

305:         for (uint256 i = 0; i < subjects.length; i++) {

307:             if (amount > 0) {

314:         if (amount > curvesTokenBalance[curvesTokenSubject][from]) revert InsufficientBalance();

330:         for (uint256 i = 0; i < subjects.length; i++) {

396:         if (supply > 1) revert CurveAlreadyExists();

416:         if (tokenBought > presalesMeta[curvesTokenSubject].maxBuy) revert ExceededMaxBuyAmount();

466:         if (amount > curvesTokenBalance[curvesTokenSubject][msg.sender]) revert InsufficientBalance();

497:         if (amount > CurvesERC20(externalToken).balanceOf(msg.sender)) revert InsufficientBalance();

498:         if (tokenAmount > curvesTokenBalance[curvesTokenSubject][address(this)]) revert InsufficientBalance();

```

```solidity
File: contracts/FeeSplitter.sol

55:         for (uint256 i = 0; i < tokens.length; i++) {

66:         if (balance > 0) {

105:         for (uint256 i = 0; i < tokenList.length; i++) {

109:             if (claimable > 0) {

```

</details>


<a name="GAS-13"></a> 
### [GAS-13] Optimize Gas by splitting `if() revert` statements
Using boolean operators in a single `if() revert` statement can consume more gas than necessary. Consider splitting these statements to save gas.

*There is one instance of this issue:*
```solidity
File: contracts/Curves.sol

265:         if (!(supply > 0 || curvesTokenSubject == msg.sender)) revert UnauthorizedCurvesTokenSubject();

```


<a name="GAS-14"></a> 
### [GAS-14] Optimize names to save gas
`public`/`external` function names and `public` member variable names can be optimized to save gas. See this [link](https://gist.github.com/IllIllI000/a5d8b486a8259f9f77891a919febd1a9) for an example of how it works. Below are the interfaces/abstract contracts that can be optimized so that the most frequently-called functions use the least amount of gas possible during method lookup. Method IDs that have two leading zero bytes can save 128 gas each during deployment, and renaming functions to have lower method IDs will save 22 gas per call, [per sorted position shifted](https://medium.com/joyso/solidity-how-does-function-name-affect-gas-consumption-in-smart-contract-47d270d8ac92)

*There are <b>5</b> instances of this issue:*
```solidity
File: contracts/Curves.sol

/// @audit `setFeeRedistributor`, `setMaxFeePercent`, `setProtocolFeePercent`, `setExternalFeePercent`, `setReferralFeeDestination`, `setERC20Factory`, `getFees`, `getPrice`, `getBuyPrice`, `getSellPrice`, `getBuyPriceAfterFee`, `getSellPriceAfterFee`, `buyCurvesToken`, `sellCurvesToken`, `transferCurvesToken`, `transferAllCurvesTokens`, `buyCurvesTokenWithName`, `buyCurvesTokenForPresale`, `setWhitelist`, `buyCurvesTokenWhitelisted`, `verifyMerkle`, `setNameAndSymbol`, `mint`, `withdraw`, `deposit`, `sellExternalCurvesToken`
41: contract Curves is CurvesErrors, Security {

```

```solidity
File: contracts/CurvesERC20.sol

/// @audit `mint`, `burn`
7: contract CurvesERC20 is ERC20, Ownable {

```

```solidity
File: contracts/CurvesERC20Factory.sol

/// @audit `deploy`
6: contract CurvesERC20Factory {

```

```solidity
File: contracts/FeeSplitter.sol

/// @audit `setCurves`, `balanceOf`, `totalSupply`, `getUserTokens`, `getUserTokensAndClaimable`, `getClaimableFees`, `claimFees`, `addFees`, `onBalanceChange`, `batchClaiming`
9: contract FeeSplitter is Security {

```

```solidity
File: contracts/Security.sol

/// @audit `setManager`, `transferOwnership`
4: contract Security {

```


<a name="GAS-15"></a> 
### [GAS-15] Reduce gas usage by moving to Solidity 0.8.19 or later
Solidity version 0.8.19 introduced a number of gas optimizations, refer to the [Solidity 0.8.19 Release Announcement](https://soliditylang.org/blog/2023/02/22/solidity-0.8.19-release-announcement/) for details.

*There are <b>5</b> instances of this issue:*
```solidity
File: contracts/Curves.sol

2: pragma solidity ^0.8.7;

```

```solidity
File: contracts/CurvesERC20.sol

2: pragma solidity ^0.8.7;

```

```solidity
File: contracts/CurvesERC20Factory.sol

2: pragma solidity ^0.8.7;

```

```solidity
File: contracts/FeeSplitter.sol

2: pragma solidity ^0.8.7;

```

```solidity
File: contracts/Security.sol

2: pragma solidity ^0.8.7;

```


<a name="GAS-16"></a> 
### [GAS-16] Unlimited gas consumption risk due to external call recipients
When calling an external function without specifying a gas limit , the called contract may consume all the remaining gas, causing the tx to be reverted. To mitigate this, it is recommended to explicitly set a gas limit when making low level external calls.

*There is one instance of this issue:*
```solidity
File: contracts/Curves.sol

232:                 (bool success1, ) = firstDestination.call{value: isBuy ? buyValue : sellValue}("");

```


<a name="GAS-17"></a> 
### [GAS-17] Optimize external calls with assembly for memory efficiency
Using interfaces to make external contract calls in Solidity is convenient but can be inefficient in terms of memory utilization. Each such call involves creating a new memory location to store the data being passed, thus incurring memory expansion costs.

Inline assembly allows for optimized memory usage by re-using already allocated memory spaces or using the scratch space for smaller datasets. This can result in notable gas savings, especially for contracts that make frequent external calls.

Additionally, using inline assembly enables important safety checks like verifying if the target address has code deployed to it using `extcodesize(addr)` before making the call, mitigating risks associated with contract interactions.

*There is one instance of this issue:*
```solidity
File: contracts/Curves.sol

/// @audit `.onBalanceChange(...)`
247:                 feeRedistributor.onBalanceChange(curvesTokenSubject, msg.sender);

```


<a name="GAS-18"></a> 
### [GAS-18] Use assembly to compute hashes to save gas
If the arguments to the encode call can fit into the scratch space (two words or fewer), then it's more efficient to use assembly to generate the hash (80 gas):

`keccak256(abi.encodePacked(x, y)) -> assembly {mstore(0x00, a); mstore(0x20, b); let hash := keccak256(0x00, 0x40); }`

<details>
<summary>
There are <b>11</b> instances (click to show):
</summary>

```solidity
File: contracts/Curves.sol

344:         if (keccak256(bytes(symbol)) == keccak256(bytes(DEFAULT_SYMBOL))) {

344:         if (keccak256(bytes(symbol)) == keccak256(bytes(DEFAULT_SYMBOL))) {

424:         bytes32 leaf = keccak256(abi.encodePacked(caller));

441:             keccak256(abi.encodePacked(externalCurvesTokens[curvesTokenSubject].name)) ==

442:             keccak256(abi.encodePacked("")) ||

443:             keccak256(abi.encodePacked(externalCurvesTokens[curvesTokenSubject].symbol)) ==

444:             keccak256(abi.encodePacked(""))

471:                 keccak256(abi.encodePacked(externalCurvesTokens[curvesTokenSubject].name)) ==

472:                 keccak256(abi.encodePacked("")) ||

473:                 keccak256(abi.encodePacked(externalCurvesTokens[curvesTokenSubject].symbol)) ==

474:                 keccak256(abi.encodePacked(""))

```

</details>


<a name="GAS-19"></a> 
### [GAS-19] Use assembly to emit events
To efficiently emit events, it's possible to utilize assembly by making use of scratch space and the free memory pointer. This approach has the advantage of potentially avoiding the costs associated with memory expansion.

However, it's important to note that in order to safely optimize this process, it is preferable to cache and restore the free memory pointer.

A good example of such practice can be seen in [Solady's](https://github.com/Vectorized/solady/blob/main/src/tokens/ERC1155.sol#L167) codebase.

*There are <b>6</b> instances of this issue:*
```solidity
File: contracts/Curves.sol

251:         emit Trade(

324:         emit Transfer(curvesTokenSubject, from, to, amount);

360:         emit TokenDeployed(curvesTokenSubject, tokenContract, name, symbol);

400:             emit WhitelistUpdated(msg.sender, merkleRoot);

```

```solidity
File: contracts/FeeSplitter.sol

86:         emit FeesClaimed(token, msg.sender, claimable);

112:                 emit FeesClaimed(token, msg.sender, claimable);

```


<a name="GAS-20"></a> 
### [GAS-20] Use assembly to validate `msg.sender`

*There are <b>2</b> instances of this issue:*
```solidity
File: contracts/Curves.sol

104:         if (curvesTokenSubject != msg.sender) revert UnauthorizedCurvesTokenSubject();

265:         if (!(supply > 0 || curvesTokenSubject == msg.sender)) revert UnauthorizedCurvesTokenSubject();

```


<a name="GAS-21"></a> 
### [GAS-21] Use assembly to write address/contract type storage values
Using `assembly { sstore(state.slot, addr)` instead of `state = addr` can save gas.

*There are <b>7</b> instances of this issue:*
```solidity
File: contracts/Curves.sol

109:         curvesERC20Factory = curvesERC20Factory_;

110:         feeRedistributor = FeeSplitter(payable(feeRedistributor_));

114:         feeRedistributor = FeeSplitter(payable(feeRedistributor_));

163:         curvesERC20Factory = factory_;

```

```solidity
File: contracts/FeeSplitter.sol

36:         curves = curves_;

```

```solidity
File: contracts/Security.sol

19:         owner = msg.sender;

28:         owner = owner_;

```


<a name="GAS-22"></a> 
### [GAS-22] Using a double `if` statement instead of a logical AND (`&&`)
Using a double `if` statement instead of a logical AND (`&&`) can provide similar short-circuiting behavior whereas double if is slightly [more gas efficient](https://gist.github.com/DadeKuma/931ce6794a050201ec6544dbcc31316c).

*There are <b>3</b> instances of this issue:*
```solidity
File: contracts/Curves.sol

182:         uint256 sum2 = supply == 0 && amount == 1

213:         if (startTime != 0 && startTime >= block.timestamp) revert SaleNotOpen();

246:             if (feesEconomics.holdersFeePercent > 0 && address(feeRedistributor) != address(0)) {

```


<a name="GAS-23"></a> 
### [GAS-23] Use a more recent version of solidity
- Use a solidity version of at least 0.8.2 to get simple compiler automatic inlining.
- Use a solidity version of at least 0.8.3 to get better struct packing and cheaper multiple storage reads.
- Use a solidity version of at least 0.8.4 to get custom errors, which are cheaper at deployment than revert()/require() strings.
- Use a solidity version of at least 0.8.10 to have external calls skip contract existence checks if the external call has a return value.

*There are <b>5</b> instances of this issue:*
```solidity
File: contracts/Curves.sol

2: pragma solidity ^0.8.7;

```

```solidity
File: contracts/CurvesERC20.sol

2: pragma solidity ^0.8.7;

```

```solidity
File: contracts/CurvesERC20Factory.sol

2: pragma solidity ^0.8.7;

```

```solidity
File: contracts/FeeSplitter.sol

2: pragma solidity ^0.8.7;

```

```solidity
File: contracts/Security.sol

2: pragma solidity ^0.8.7;

```


<a name="GAS-24"></a> 
### [GAS-24] Use `uint256(1)`/`uint256(2)` instead of `true`/`false` to save gas for changes
Avoids a Gsset (20000 gas) when changing from false to true, after having been true in the past. Since most of the bools aren't changed twice in one transaction, I've counted the amount of gas as half of the full amount, for each variable.

*There is one instance of this issue:*
```solidity
File: contracts/Security.sol

6:     mapping(address => bool) public managers;

```


<a name="GAS-25"></a> 
### [GAS-25] Use `unchecked` block for safe subtractions
If it can be confirmed that the subtraction operation will not overflow, using an unchecked block can save gas. For example, `require(x <= y); z = y - x;` can be optimized to `require(x <= y); unchecked { z = y - x; }`

*There are <b>4</b> instances of this issue:*
```solidity
File: contracts/Curves.sol

/// @audit this subtraction is checked on line 201
208:         return price - totalFee;

/// @audit this subtraction is checked on line 184
259:             isBuy ? supply + amount : supply - amount

/// @audit this subtraction is checked on line 184
287:         uint256 price = getPrice(supply - amount, amount);

/// @audit this subtraction is checked on line 184
290:         curvesTokenSupply[curvesTokenSubject] = supply - amount;

```


<a name="GAS-26"></a> 
### [GAS-26] Using bitmap to store bool states can save gas
Using a bitmap instead of a bool array or a bool mapping to store boolean states can save gas fees. This is because the bitmap can store 256 boolean values in a single slot instead of 256 slots, which can save gas when writing bool values or when reading multiple bool values from the same slot.

*There is one instance of this issue:*
```solidity
File: contracts/Security.sol

6:     mapping(address => bool) public managers;

```


<a name="GAS-27"></a> 
### [GAS-27] Using `constant`s directly, rather than caching the value, saves gas

*There are <b>4</b> instances of this issue:*
```solidity
File: contracts/Curves.sol

/// @audit `DEFAULT_NAME`
446:             externalCurvesTokens[curvesTokenSubject].name = DEFAULT_NAME;

/// @audit `DEFAULT_SYMBOL`
447:             externalCurvesTokens[curvesTokenSubject].symbol = DEFAULT_SYMBOL;

/// @audit `DEFAULT_NAME`
476:                 externalCurvesTokens[curvesTokenSubject].name = DEFAULT_NAME;

/// @audit `DEFAULT_SYMBOL`
477:                 externalCurvesTokens[curvesTokenSubject].symbol = DEFAULT_SYMBOL;

```


<a name="GAS-28"></a> 
### [GAS-28] `array[index] += amount` is cheaper than `array[index] = array[index] + amount` (or related variants)
When updating a value in an array with arithmetic, using `array[index] += amount` is cheaper than `array[index] = array[index] + amount`.
This is because you avoid an additonal `mload` when the array is stored in memory, and an `sload` when the array is stored in storage.
This can be applied for any arithmetic operation including `+=`, `-=`,`/=`,`*=`,`^=`,`&=`, `%=`, `<<=`,`>>=`, and `>>>=`.
This optimization can be particularly significant if the pattern occurs during a loop.

*Saves 28 gas for a storage array, 38 for a memory array*

*There are <b>2</b> instances of this issue:*
```solidity
File: contracts/Curves.sol

321:         curvesTokenBalance[curvesTokenSubject][from] = curvesTokenBalance[curvesTokenSubject][from] - amount;

322:         curvesTokenBalance[curvesTokenSubject][to] = curvesTokenBalance[curvesTokenSubject][to] + amount;

```


<a name="GAS-29"></a> 
### [GAS-29] Using bools for storage incurs overhead
Use uint256(1) and uint256(2) for true/false to avoid a Gwarmaccess (100 gas), and to avoid Gsset (20000 gas) when changing from ‘false’ to ‘true’, after having been ‘true’ in the past. See [source](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/58f635312aa21f947cae5f8578638a85aa2519f5/contracts/security/ReentrancyGuard.sol#L23-L27).

*There is one instance of this issue:*
```solidity
File: contracts/Security.sol

6:     mapping(address => bool) public managers;

```


<a name="GAS-30"></a> 
### [GAS-30] Cache array length outside of loop
If not cached, the solidity compiler will always read the length of the array during each iteration. That is, if it is a storage array, this is an extra sload operation (100 additional extra gas for each iteration except for the first) and if it is a memory array, this is an extra mload operation (3 additional gas for each iteration except for the first).

*There are <b>4</b> instances of this issue:*
```solidity
File: contracts/Curves.sol

305:         for (uint256 i = 0; i < subjects.length; i++) {

330:         for (uint256 i = 0; i < subjects.length; i++) {

```

```solidity
File: contracts/FeeSplitter.sol

55:         for (uint256 i = 0; i < tokens.length; i++) {

105:         for (uint256 i = 0; i < tokenList.length; i++) {

```


<a name="GAS-31"></a> 
### [GAS-31] State variables should be cached in stack variables rather than re-reading them from storage
The instances below point to the second+ access of a state variable within a function. Caching of a state variable replaces each Gwarmaccess (100 gas) with a much cheaper stack read. Other less obvious fixes/optimizations include having local memory caches of state variable structs, or having local caches of state variable contracts/addresses.

*There are <b>2</b> instances of this issue:*
```solidity
File: contracts/Curves.sol

/// @audit more than 1 read for `curvesTokenBalance`, line 322 and 321
322:         curvesTokenBalance[curvesTokenSubject][to] = curvesTokenBalance[curvesTokenSubject][to] + amount;

/// @audit more than 1 read for `externalCurvesTokens`, line 484 and 468
484:             externalToken = externalCurvesTokens[curvesTokenSubject].token;

```


<a name="GAS-32"></a> 
### [GAS-32] Use `calldata` instead of `memory` for function arguments that do not get mutated
Mark data types as `calldata` instead of `memory` where possible. This makes it so that the data is not automatically loaded into memory. If the data passed into the function does not need to be changed (like updating values in an array), it can be passed in as `calldata`. The one exception to this is if the argument must later be passed into another function that takes an argument that specifies `memory` storage.

*There are <b>10</b> instances of this issue:*
```solidity
File: contracts/Curves.sol

367:         string memory name,

368:         string memory symbol

407:         bytes32[] memory proof

422:     function verifyMerkle(address curvesTokenSubject, address caller, bytes32[] memory proof) public view {

430:         string memory name,

431:         string memory symbol

```

```solidity
File: contracts/CurvesERC20.sol

8:     constructor(string memory name_, string memory symbol_, address owner) ERC20(name_, symbol_) {

8:     constructor(string memory name_, string memory symbol_, address owner) ERC20(name_, symbol_) {

```

```solidity
File: contracts/CurvesERC20Factory.sol

7:     function deploy(string memory name, string memory symbol, address owner) public returns (address) {

7:     function deploy(string memory name, string memory symbol, address owner) public returns (address) {

```


<a name="GAS-33"></a> 
### [GAS-33] Don't initialize variables with default value

*There are <b>6</b> instances of this issue:*
```solidity
File: contracts/Curves.sol

47:     uint256 private _curvesTokenCounter = 0;

305:         for (uint256 i = 0; i < subjects.length; i++) {

330:         for (uint256 i = 0; i < subjects.length; i++) {

```

```solidity
File: contracts/FeeSplitter.sol

55:         for (uint256 i = 0; i < tokens.length; i++) {

104:         uint256 totalClaimable = 0;

105:         for (uint256 i = 0; i < tokenList.length; i++) {

```


<a name="GAS-34"></a> 
### [GAS-34] Constructors can be marked as `payable` to save deployment gas
Payable functions cost less gas to execute, because the compiler does not have to add extra checks to ensure that no payment is provided. A constructor can be safely marked as payable, because only the deployer would be able to pass funds, and the project itself would not pass any funds.

*There are <b>4</b> instances of this issue:*
```solidity
File: contracts/Curves.sol

108:     constructor(address curvesERC20Factory_, address feeRedistributor_) Security() {

```

```solidity
File: contracts/CurvesERC20.sol

8:     constructor(string memory name_, string memory symbol_, address owner) ERC20(name_, symbol_) {

```

```solidity
File: contracts/FeeSplitter.sol

33:     constructor() Security() {}

```

```solidity
File: contracts/Security.sol

18:     constructor() {

```


<a name="GAS-35"></a> 
### [GAS-35] Functions guaranteed to revert when called by normal users can be marked `payable`
If a function modifier such as `onlyOwner` is used, the function will revert if a normal user tries to pay the function. Marking the function as `payable` will lower the gas cost for legitimate callers because the compiler will not include checks for whether a payment was provided.

<details>
<summary>
There are <b>11</b> instances (click to show):
</summary>

```solidity
File: contracts/Curves.sol

113:     function setFeeRedistributor(address feeRedistributor_) external onlyOwner {

117:     function setMaxFeePercent(uint256 maxFeePercent_) external onlyManager {

128:     function setProtocolFeePercent(uint256 protocolFeePercent_, address protocolFeeDestination_) external onlyOwner {

162:     function setERC20Factory(address factory_) external onlyOwner {

439:     function mint(address curvesTokenSubject) external onlyTokenSubject(curvesTokenSubject) {

```

```solidity
File: contracts/CurvesERC20.sol

12:     function mint(address to, uint256 amount) public onlyOwner {

16:     function burn(address from, uint256 amount) public onlyOwner {

```

```solidity
File: contracts/FeeSplitter.sol

89:     function addFees(address token) public payable onlyManager {

96:     function onBalanceChange(address token, address account) public onlyManager {

```

```solidity
File: contracts/Security.sol

23:     function setManager(address manager_, bool value) public onlyOwner {

27:     function transferOwnership(address owner_) public onlyOwner {

```

</details>


<a name="GAS-36"></a> 
### [GAS-36] `++i` costs less gas than `i++`, especially when it's used in `for`-loops (`--i`/`i--` too)
*Saves 5 gas per loop*

*There are <b>4</b> instances of this issue:*
```solidity
File: contracts/Curves.sol

305:         for (uint256 i = 0; i < subjects.length; i++) {

330:         for (uint256 i = 0; i < subjects.length; i++) {

```

```solidity
File: contracts/FeeSplitter.sol

55:         for (uint256 i = 0; i < tokens.length; i++) {

105:         for (uint256 i = 0; i < tokenList.length; i++) {

```


<a name="GAS-37"></a> 
### [GAS-37] Using `private` rather than `public` for constants, saves gas
If needed, the values can be read from the verified contract source code, or if there are multiple values there can be a single getter function that [returns a tuple](https://github.com/code-423n4/2022-08-frax/blob/90f55a9ce4e25bceed3a74290b854341d8de6afa/src/contracts/FraxlendPair.sol#L156-L178) of the values of all currently-public constants. Saves **3406-3606 gas** in deployment gas due to the compiler not having to create non-payable getter functions for deployment calldata, not having to store the bytes of the value outside of where it's used, and not adding another entry to the method ID table

*There are <b>2</b> instances of this issue:*
```solidity
File: contracts/Curves.sol

44:     string public constant DEFAULT_NAME = "Curves";

45:     string public constant DEFAULT_SYMBOL = "CURVES";

```


<a name="GAS-38"></a> 
### [GAS-38] Using assembly to check for zero can save gas
Using assembly to check for zero can save gas by allowing more direct access to the evm and reducing some of the overhead associated with high-level operations in solidity.

<details>
<summary>
There are <b>22</b> instances (click to show):
</summary>

```solidity
File: contracts/Curves.sol

135:             protocolFeeDestination_ == address(0)

181:         uint256 sum1 = supply == 0 ? 0 : ((supply - 1) * (supply) * (2 * (supply - 1) + 1)) / 6;

182:         uint256 sum2 = supply == 0 && amount == 1

213:         if (startTime != 0 && startTime >= block.timestamp) revert SaleNotOpen();

227:             bool referralDefined = referralFeeDestination[curvesTokenSubject] != address(0);

246:             if (feesEconomics.holdersFeePercent > 0 && address(feeRedistributor) != address(0)) {

277:         if (curvesTokenBalance[curvesTokenSubject][msg.sender] - amount == 0) {

350:         if (symbolToSubject[symbol] != address(0)) revert InvalidERC20Metadata();

371:         if (supply != 0) revert CurveAlreadyExists();

386:         if (supply != 0) revert CurveAlreadyExists();

389:         presalesMeta[curvesTokenSubject].maxBuy = (maxBuy == 0 ? type(uint256).max : maxBuy);

410:             presalesMeta[curvesTokenSubject].startTime == 0 ||

433:         if (externalCurvesTokens[curvesTokenSubject].token != address(0)) revert ERC20TokenAlreadyMinted();

434:         if (symbolToSubject[symbol] != address(0)) revert InvalidERC20Metadata();

461:         if (externalCurvesTokens[curvesTokenSubject].token != address(0)) revert ERC20TokenAlreadyMinted();

469:         if (externalToken == address(0)) {

491:         if (amount % 1 ether != 0) revert NonIntegerDepositAmount();

496:         if (externalToken == address(0)) revert TokenAbsentForCurvesTokenSubject();

505:         if (externalCurvesTokens[curvesTokenSubject].token == address(0)) revert TokenAbsentForCurvesTokenSubject();

```

```solidity
File: contracts/FeeSplitter.sol

83:         if (claimable == 0) revert NoFeesToClaim();

91:         if (totalSupply_ == 0) revert NoTokenHolders();

115:         if (totalClaimable == 0) revert NoFeesToClaim();

```

</details>


